弹性物体模拟的话，简单来说就是物体不希望自己发生变形，如果外力让自己发生变形的话，那么就使用外力转换成的内能让自己变回去。

或者说，外力改变我的形状，但外力转变成了我的内能，于是我又用内能把我的形状改回去了。

比如我手上有一块喷香的面包，我用手稍微将它扯一下，那么面包会变长一些，但是如果我放开我的手的话，那么它又会变回原来的形状。衣服也是如此，扯一下衣服会变形，放开的话衣服又会变回去。

计算物理这种东西举例子最有效，比如一个二维三角形，它的三个顶点分别是
$$
\bold X_0 = \begin{bmatrix} 0 \\ 0\end{bmatrix} \qquad \bold X_1 = \begin{bmatrix} 1 \\ 0\end{bmatrix} \qquad \bold X_2 = \begin{bmatrix} 0 \\ 1\end{bmatrix}
$$
现在假设这个三角形发生了平移，那么这个三角形算不算变形呢？需不需要变回原来的形状呢？
$$
\bold x_0 = \begin{bmatrix} 0 \\ 1\end{bmatrix} \qquad \bold x_1 = \begin{bmatrix} 1 \\ 1\end{bmatrix} \qquad \bold x_2 = \begin{bmatrix} 0 \\ 2\end{bmatrix}
$$
最好从现实中找例子。比如我手上有一块面包，它由很多三角形构成，那么我它从手上放到餐盘上，那么它算不算变形，并且从餐盘上跳回来到我手上来呢？

如果你的答案是“是”的话，那么我怀疑你并不生活在地球上。为了压住牛顿的棺材板，我们需要假设纯位移的情况，三角形不变形，面积没有变化，不产生能量，也不产生力。

因此我们需要找到一个能量公式，经过一番计算后，得到的结果是零。这个能量公式需要自己造。

为了解释清楚这个能量公式，需要先扯一些连续介质力学的东西。首先就是变形梯度(deformation gradient)，这是一个矩阵，这个的矩阵的最终目的就是弄清楚物体从最初形态到现在的形态经历了哪些不可描述的变化
$$
d\bold x = \bold F d\bold X \qquad \bold F = \frac{d \bold x}{d\bold X}
$$
小x是现在顶点的位置，大X是顶点初始位置，F是变形梯度。其中dX是对顶点的微分
$$
d\bold X = \begin{bmatrix} \bold X_1 - \bold X_0 & \bold X_2 - \bold X_0\end{bmatrix}
= \begin{bmatrix} 1 & 0  \\ 0 & 1\end{bmatrix} \qquad d \bold X^{-1} = \begin{bmatrix} 1 & 0  \\ 0 & 1\end{bmatrix}
$$
dx也就是相似的计算，纯位移的情况下，三角形三个顶点的相对位置不发生变化，那么
$$
d\bold x = \begin{bmatrix} \bold x_1 - \bold x_0  & \bold x_2 - \bold x_0\end{bmatrix} = \begin{bmatrix} 1 & 0  \\ 0 & 1\end{bmatrix}
$$
不过有的书上对变形梯度是这么写的
$$
\bold F = \bold D_s \bold D_m^{-1}
$$
Ds 就是现在顶点位置就是dx，Dm就是初始顶点位置就是dX。最终变形梯度计算结果如下
$$
\bold F = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}
$$
这就是二维情况下，纯位移的形变梯度，是一个单位矩阵。现在我们要通过一些操作，利用变形梯度计算能量，也就是把这个东西变成数字零。

最容易想到的就是直接让矩阵各个数字相加，这就是Dirchlet能量。
$$
\psi = ||\bold F||_F^2 = \sum_{i=0}^2 \sum_{j=0}^2 f_{ij}^2 = 1^2 + 0^2 + 0^2 + 1 ^2 = 2
$$
很好，这相当于告诉你物体在没用受到任何外力或内力的作用下，纯位移也能产生能量。显然这并不是地球上应该发生的事，所以我们不能用这个公式。

那么有的人就说了，减去2不就好了吗，但是，如果三角形面积变小的话，产生的能量就是负数了，也就是外力并没有转换为内能或热能，而是凭空消失了。这也不太好。

## 线弹性

既然Dirchlet能量不能用，那么我们就换个公式呗。也就是大名鼎鼎的线弹性模型(linear elasticity)
$$
\psi = \mu \varepsilon :\varepsilon + \frac{\lambda}{2}tr^2(\varepsilon)
$$
其中varespilon 是 应变张量(strain tensor, green strain)
$$
\varepsilon = (\bold F + \bold F^T)/2 - \bold I
$$
当变形梯度为单位矩阵时，应变张量就是全零矩阵。相当于没有应变。如果你对这些不熟悉，应该看看弹性力学和连续介质力学相关的书籍。在PositionBasedDynmics 库中，上面一段公式是这么写的。

```
epsilon(0, 0) = static_cast<Real>(0.5)*(F(0, 0) * F(0, 0) + F(1, 0) * F(1, 0) + F(2, 0) * F(2, 0) - static_cast<Real>(1.0));		// xx
...

const Real trace = epsilon(0, 0) + epsilon(1, 1) + epsilon(2,2);
const Real ltrace = lambda*trace;

Real psi = 0.0;
for (unsigned char j = 0; j < 3; j++)
	for (unsigned char k = 0; k < 3; k++)
		psi += epsilon(j, k) * epsilon(j, k);
psi = mu*psi + static_cast<Real>(0.5)*lambda * trace*trace;
energy = restVolume * psi;
```

这种模型的优点是计算简单友好，适用于处理小变形的情况。比方说，这个三角形的x轴被拉长，顶点变成了下面这种方式
$$
\bold x_0 = \begin{bmatrix} 0 \\ 0\end{bmatrix} \qquad \bold x_1 = \begin{bmatrix} 2 \\ 0\end{bmatrix} \qquad \bold x_2 = \begin{bmatrix} 0 \\ 1\end{bmatrix}
$$
此时dx和变形梯度如下
$$
d\bold x = \begin{bmatrix} 2 & 0 \\ 0 & 1 \end{bmatrix} \qquad \bold F =  \begin{bmatrix} 2 & 0 \\ 0 & 1 \end{bmatrix}
$$
那么应变张量和能量就是
$$
\varepsilon = \begin{bmatrix} 1 & 0 \\ 0 & 0 \end{bmatrix} \qquad \psi = \mu + \frac{\lambda}{2}
$$
很好能量算出来了，我们就要根据能量的导数来算力了。

## 节点力的计算

接下来开始劝退。仍然建议你先看有关弹性力学与连续介质的力学的书籍。先把stress的计算公式甩上来。先让能量对变形梯度求导得到应力，然后应力对结点求导得到真正的力
$$
\frac{\partial \Psi}{\partial \bold F} = \bold P(\bold F) \qquad \bold f(\bold x) = \nabla \bold P(\bold F) 
$$
Psi 是刚才算出的能量，F是变形梯度，P 是first piola krichhoff stress 。对于线弹性力来说，求导如下
$$
\bold P(\bold F) = \mu(\bold F + \bold F^T - 2\bold I) + \lambda tr(\bold F  - \bold I)\bold I
$$
并且计算物理中关于这种矩阵求导的非常非常多，很多教程，比如Physics Based Animation那些讲义和games103，推导得也很简单不详细，很少谈及它为什么会是这样。自己看到公式，或自己求导完又不知道对不对，又不敢写成代码，而且无人讨论。

这个问题我一直思考了很久，我认为比较靠谱的就是参考开源计算库，然后尽力手写简单的例子，最后博览群书，期待某篇文章中的某句话能够解答我的疑惑。正如我在这篇文章中所做的，至少能帮助我误入歧途，并且思路清晰。

比如Bullet3库是这么写的

```
btMatrix3x3 dP = (dF + dF.transpose()) * mu_damp + I * ((dF[0][0] + dF[1][1] + dF[2][2]) * lambda_damp);
btMatrix3x3 df_on_node123 = dP * tetra.m_Dm_inverse.transpose();
```

又比如PositionBasedDynamics库是这么写的

```
// P(F) = F(2 mu E + lambda tr(E)I) => E = green strain
sigma = epsilon * 2.0*mu;
sigma(0, 0) += ltrace;
sigma(1, 1) += ltrace;
sigma(2, 2) += ltrace;
sigma = F * sigma;
```

再手算一遍，假设mu和lambda都是2，那么线弹性能量就是3，那么第一piola krichhoff  应力
$$
\bold P(\bold F) = 2\mu \bold E + \lambda tr(\bold E)\bold I \\
= (2\mu \begin{bmatrix} 1 & 0 \\ 0 & 0\end{bmatrix} + \lambda\begin{bmatrix} 1 & 0 \\ 0 & 1\end{bmatrix}) = \begin{bmatrix} 6 & 0 \\ 0 & 2\end{bmatrix}
$$
好了，算好应力后，接下来对它求导得出节点力G，在“Robust Quasistatic Finite Elements and Flesh Simulation  ” 是这么写的
$$
\bold g_i = -\bold P (A_1 \bold N_1 + A_2 \bold N_2 + A_3 \bold N_3)/3 \qquad \bold g_0 = -(\bold g_1 + \bold g_2 + \bold g_3)
$$
其中AN是当前元素，即三角形的法向量根据面积的权重。并且节点0的力是节点123的力相加并乘以-1。另一种方法是
$$
\bold G = \bold P \bold B \qquad \bold G = (\bold g_1,\bold g_2, \bold g_3) \qquad \bold B_m = (\bold b_1,\bold b_2,\bold b_3) = -V\bold D_m^{-T}
$$
在“FEM Simulation of 3D Deformable Solids: A practitioner’s guide to theory, discretization and model reduction.” 是这么写的，推导也很详细。
$$
\bold H = \begin{bmatrix} \vec f_1 & \vec f_2 & \vec f_3\end{bmatrix} = -W\bold P(\bold F)\bold D_m^{-T} \qquad \vec f_0 = -\vec f_1 - \vec f_2 - \vec f_3
$$
看代码吧，其中bullet3库是这么写的。得出力后，再把相加到节点力上

```
btVector3 grad_N_hat_1st_col = btVector3(-1, -1, -1);
btVector3 df_on_node0 = df_on_node123 * grad_N_hat_1st_col;
btScalar scale1 = scale * tetra.m_element_measure;
force[id0] -= scale1 * df_on_node0;
force[id1] -= scale1 * df_on_node123.getColumn(0);
force[id2] -= scale1 * df_on_node123.getColumn(1);
force[id3] -= scale1 * df_on_node123.getColumn(2);
```

算出应力后，再计算真正的节点力。其中sigma就是第一piola krichhoff 应力，J就是节点力

```
T = invRestMat.transpose();
H = sigma * T * restVolume;
J[0][0] = H(0, 0);	J[1][0] = H(0, 1);	J[2][0] = H(0, 2);
J[0][1] = H(1, 0);	J[1][1] = H(1, 1);	J[2][1] = H(1, 2);
J[0][2] = H(2, 0);	J[1][2] = H(2, 1);	J[2][2] = H(2, 2);
J[3] = -J[0] - J[1] - J[2];
```

继续手推，
$$
\bold H = -W\bold P(\bold F)d\bold X^{-T} = -\frac{1}{2}\begin{bmatrix} 6 & 0 \\ 0 & 2\end{bmatrix} \begin{bmatrix} 1 & 0 \\ 0 & 1\end{bmatrix} = \begin{bmatrix} -3 & 0 \\ 0 & -1\end{bmatrix} 
$$
也就是
$$
\vec f_0 = \begin{bmatrix} 3 \\ 1\end{bmatrix} \qquad \vec f_1 = \begin{bmatrix} -3 \\ 0\end{bmatrix} \qquad \vec f_2 = \begin{bmatrix} 0 \\ -1\end{bmatrix}
$$
那么最简单的二维线弹性显式求解如下

```
import numpy as np
# 初始化三角形初始位置
node_pos = np.array([[0,0],[1,0],[0,1]],dtype = float)
# 顶点的位置梯度
Ds = np.array([[node_pos[1,0] - node_pos[0,0],node_pos[2,0] -
node_pos[0,0]],
[node_pos[1,1] - node_pos[0,1],node_pos[2,1] -
node_pos[0,1]]])
# 求逆，用于准备计算形变梯度
minv = np.linalg.inv(Ds)
# 假设某一时刻，三角形变化到了这样的位置
node_pos = np.array([[0,0],[2,0],[0,1]],dtype = float)
time = 0
timeFinal = 100
areat = np.zeros((timeFinal))
while(time < timeFinal):
    time += 1
    # 形变梯度中的分子
    Ds_new = np.array([[node_pos[1,0] - node_pos[0,0],node_pos[2,0]
    - node_pos[0,0]],
    [node_pos[1,1] - node_pos[0,1],node_pos[2,1] -
    node_pos[0,1]]])
    # 形变梯度
    F = np.dot(Ds_new,minv)
    # 应力，也就是varepsilon
    strain = (F + F.T) * 0.5 - np.identity(2)
    # lame常数
    mu = 2
    # lame常数
    la = 2
    #
    doubleInner = strain[0,0]*strain[0,0] + strain[1,0]*strain[1,0] + strain[0,1]*strain[0,1] + strain[1,1]*strain[1,1]
    # 线弹性的能量计算公式
    energy = doubleInner * mu + la * 0.5 * np.trace(strain) ** 2
    #first piola kirchhoff stress
    piola = mu * (F + F.T - 2 * np.identity(2)) + la * (F[0,0] - 1 + F[1,1] - 1) * np.identity(2)
    # 三角形面积
    area = 0.5
    # 计算力
    H = - area * np.dot(piola,minv.transpose())
    gradC0 = np.array([H[0,0],H[1,0]])
    gradC1 = np.array([H[0,1],H[1,1]])
    gradC2 = - gradC0 - gradC1
    invMass = 1
    dt = 0.1
    # 判断是否收敛
    sumGradC = invMass * (gradC0[0]**2 + gradC0[1]**2)
    sumGradC += invMass * (gradC1[0]**2 + gradC1[1]**2)
    sumGradC += invMass * (gradC2[0]**2 + gradC2[1]**2)
    if sumGradC < 1e-10:
        break
    # 校正位置，方法来源于PositionBasedDynamics
    node_pos[0,:] += dt * energy / sumGradC * invMass * gradC2
    node_pos[1,:] += dt * energy / sumGradC * invMass * gradC0
    node_pos[2,:] += dt * energy / sumGradC * invMass * gradC1
    areat[time - 1] = 0.5 * (node_pos[0,0] * (node_pos[1,1] - node_pos[2,1])
                    + node_pos[1,0] * (node_pos[2,1] - node_pos[0,1]) 
                    + node_pos[2,0] * (node_pos[0,1] - node_pos[1,1]))
    
```

不过如果使用上面的式子，你会发现甚至算不出正确的结果，因为我们线弹性忽略一个非常重要的东西，旋转。这是不对的，因为旋转并未造成面积改变。举个例子，仍然是之前那个三角形，不过现在逆时针旋转90度
$$
\bold x_0 = \begin{bmatrix} 0 \\ 0\end{bmatrix} \qquad \bold x_1 = \begin{bmatrix} 0 \\ 1\end{bmatrix} \qquad \bold x_2 = \begin{bmatrix} -1 \\ 0\end{bmatrix}
$$
此时dx和变形梯度如下
$$
d\bold x = \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix} \qquad \bold F = \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix}
$$
那么应变张量和能量就是
$$
\varepsilon = \begin{bmatrix} -1 & -1 \\ 1 & -1 \end{bmatrix} \qquad \psi = 4\mu + 4 \frac{\lambda}{2}
$$
因为mu和lambda不为零，那么能量也必不为零，但是，你所做的，仅仅是旋转了物体而已，却也凭空产生能量。线弹性的另外一个缺点是，当变形程度太大，由于恢复力与变形程度是线性关系，所以恢复初始形状来很缓慢。另一个很严重的问题是，这里的旋转也会被当作形变，所以这个公式在图形学中用的并不多。

## STVK

接下来是一个非常重要，非常重要，非常重要的准则，重要的事说三遍， St. Venant-Kirchhoff model，参考[1]的p18 section 3.3

- 不受刚体运动，即旋转和位移的影响，因为这两种都不算形变，面积没有改变因为我们选择的是基于GreenStrain的模型，算的是形变梯度的二次方，这种模型
- 会忽视面积符号的改变，只求把模型面积的绝对值弄成原来的样子。因此如果面积/体积被改变得小于零，那么改变也仍然会继续下去。详见参考[2]第3节
- 当面积被改变的范围在0~58%的范围内，恢复力会随着形变程度的提高而增强，然而超过这个范围后，恢复力将减弱，因此不适用于大形变

至于第三个特点，为什么是58%，我们可以写个程序验证一下

```
import numpy as np
F = np.array([[1,0],[0,0.4]])
H = np.zeros((100,2,2))
for i in range(100):
F[1,1] = i / 100
E = np.dot(F,F.T) - np.identity(2)
P = np.dot(F,2*E + (E[0,0] + E[1,1])*np.identity(2))
H[i,:,:] = - P
```

仍然使用之前的代码，然后仅仅需要改变三行代码，就能将线弹性模型换成stvk模型

```
# Green Strain，也就是E
E = (np.dot(F,F.T)- np.identity(2)) * 0.5
# Stvk的能量计算公式
energy = doubleInner * mu + la / 2 * (E[0,0] + E[1,1])**2
#first piola kirchhoff stress
piola = np.dot(F, 2 * mu * E + la * (E[0,0] + E[1,1]) * np.identity(2))
```

最后计算的各顶点位置和形变梯度如下
$$
\bold x_0 =\begin{bmatrix} 0.427 \\ -0.072\end{bmatrix} \qquad \bold x_1 =\begin{bmatrix} 1.395 \\ 0.177\end{bmatrix} \qquad \bold x_2 =\begin{bmatrix} 0.177 \\ 0.895\end{bmatrix} \qquad \bold F = \begin{bmatrix} 0.968 & -0.250 \\ 0.250 & 0.968\end{bmatrix}
$$
除了线弹性模型，stvk模型外，还要neohookean模型，arap模型和corotational模型。不过neohookean模型似乎有点问题，后两者需要用到奇异值分解，之后再介绍。

# 隐式

对于每个元素，也就是每个二维三角形来说，都有一个变形梯度矩阵，是2x2的。

如果让变形梯度对顶点求导，那么就得到一个3x2x2x2的张量，因为要对每个顶点求导，因此乘三，顶点位置是二维的需要再乘以2。

注意
$$
\bold D_s = [\bold x_1 - \bold x_0 \quad |\quad  \bold x_2 - \bold x_0]
$$
如果我们重新划分一下现在的顶点位置
$$
\bold x = \begin{bmatrix} \bold x_0 \\ \bold x_1 \\ \bold x_2 \end{bmatrix} = \begin{bmatrix} x_0 \\  x_1 \\  x_2 \\ .. \\ x_5 \end{bmatrix} \quad \bold x_0 = \begin{bmatrix} x_0 \\ x_1 \end{bmatrix}\quad \bold x_1 = \begin{bmatrix} x_2 \\ x_3 \end{bmatrix}\quad \bold x_2 = \begin{bmatrix} x_4 \\ x_5 \end{bmatrix}
$$
因此我们可以很方便得求导这个3x2x2x2的张量
$$
\frac{\partial \bold D_s}{\partial x _0} = \begin{bmatrix} -1 & - 1 \\ 0 & 0\end{bmatrix} \qquad \frac{\partial \bold D_s}{\partial x _1} = \begin{bmatrix} 0 & 0 \\ -1 & -1\end{bmatrix} \\
\frac{\partial \bold D_s}{\partial x _2} = \begin{bmatrix} 1 & 0 \\ 0 & 0\end{bmatrix} \qquad \frac{\partial \bold D_s}{\partial x _3} = \begin{bmatrix} 0 &  0 \\ 1 & 0\end{bmatrix} \\
\frac{\partial \bold D_s}{\partial x _4} = \begin{bmatrix} 0 & 1 \\ 0 & 0\end{bmatrix} \qquad \frac{\partial \bold D_s}{\partial x _5} = \begin{bmatrix} 0 & 0 \\ 0 & 1\end{bmatrix}
$$
如果你对上面感到困惑不解，那么请回忆
$$
\bold D_s = \begin{bmatrix} x_2 - x_0 & x_4 - x_0\\ x_3 - x_1 & x_5 - x_1\end{bmatrix}
$$
既然dD 是 4阶张量有24个数字，那么dF 也是一样是四阶张量有24个数字。

最后，这个3x2x2x2的张量，会被扩充成3x3x2x2个，也就是3x3个2x2矩阵，记住3是顶点数，2是维度数。然后dH可以直接组装到矩阵K里面去，

怎么填充，因为我们有三个顶点，三个顶点会相互作用，所以有3x3个位置，每个位置也是2x2矩阵，代表的是维度，

可以参照的方法，一列一列填，每一列都需要9个2x2矩阵中的1个2x2矩阵。



我突然觉得，如果你对有限元掌握的不多的话，一定看不懂我在写什么。但是如果要写得详细的话，会多写出几万字出来。而且大部分时间都在求解什么板单元壳单元，几乎全是公式和代码，毫无视觉效果，写出来又没人看，屮。

