很多教程一上来就三维的，太复杂了，所以为什么不能从一维开始慢慢推起呢？

如果你有任何不懂的地方，欢迎问我。如果你在长沙，也欢迎当面来互相交流。因为我一个人写这些东西有点孤单。

## 一维显式方法

假设有两个点，它们都是一维的，起始位置为
$$
x_0 = 1 \qquad x_1 =3
$$
那么对位置求导得
$$
d\bold X = \bold D_m = x_1 - x_0 = 2\qquad d\bold X^{-1} = \bold D_m^{-1} = 0.5
$$
假设现在两个顶点位置运动到了
$$
x_0 = 1 \qquad x_1 = 5
$$
那么继续对位置求导
$$
d\bold x = \bold D_s =  x_1 - x_0 = 4 \qquad \bold F = \frac{d\bold  x}{d\bold X} = 2
$$
那么Green应变和第一pk应力计算如下，假设mu = lambda = 2
$$
\bold E = (\bold F^T \bold F - \bold I)/2 = \frac{3}{2} \qquad \bold P = \bold F(2\mu \bold E + \lambda tr(\bold E)\bold I) = 18
$$
那么hessian矩阵就是
$$
H = -W \bold P \bold D_m^T = - 2 * 18 * 0.5 = -18
$$
hessian矩阵同时顶点一的力，顶点零的力则是反过来的
$$
\bold f_1 = \bold H_{00} =  -18 \qquad \bold f_0 =  \bold f_1 = 18
$$
显式方法的话，只需要将力乘上时间，除以质量就可以放到速度上，然后再让速度乘上时间就可以加到位置上，很快就能收敛。

## 一维隐式方法

接下来开始隐式方法，首先是Ds对两个顶点求导
$$
\frac{\partial \bold D_s}{\partial x_0} = - 1 \qquad \frac{\partial \bold D_s}{\partial x_1} = 1
$$
请想清楚这里求导的意义，这代表x0 每前进1，那么Ds 就会减少1。而如果x1每前进1，那么Ds就增加1。而Ds正是x1与x0之间的距离。并且求导之后得到的东西是一个有2x1x1x1 = 2个元素的四阶张量。第一个2是因为一个线段有两个顶点，第一个1是因为这两个顶点的位置都是一维的，之后两个1也是因为一维的关系。

或者换种想法，这个四阶张量，其实是2x1个1x1矩阵。

然后是变形求导
$$
\delta \bold F = \delta \bold D_s \bold D_m^{-1} \qquad \frac{\partial \bold F}{\partial x_0} = \frac{\partial \bold D_s}{\partial x_0} \bold D_m^{-1} = -\frac{1}{2} \qquad \frac{\partial \bold F}{\partial x_1} = \frac{1}{2}
$$
这里变形梯度与位置仍然是线性的，如果x0能够前进1，那么线段的长度就是初始长度，变形梯度也变成单位矩阵了。然后应变求导
$$
\delta \bold E = \frac{1}{2}(\delta \bold F^T \bold F + \bold F^T \delta \bold F) \qquad \frac{\partial \bold E}{\partial x_0} = - 
1 \qquad \frac{\partial \bold E}{\partial x_1} = 1
$$
这里应变与位置的关系不是线性的，但是当x0前进1，可以用一阶导粗略得算出应变减少3/4，虽然有误差，但是误差是导数不够精确造成的。物理意义仍然没错。

然后算第一pk应力的导
$$
\delta \bold P = \delta \bold F [2\mu \bold E + \lambda tr(\bold E)\bold I] + \bold F(2\mu \delta \bold E + \lambda tr(\bold \delta \bold E)\bold I) \\
\frac{\partial \bold P}{\partial x_0} = -\frac{1}{2}(2*2*\frac{3}{2} + 2*\frac{3}{2}) + 2(2*2* (-1) + 2 * (-1)) = -33/2 \\ 
\frac{\partial \bold P}{\partial x_1}  = 33/2
$$
这里第一pk力与位置的关系仍然不是线性的。但是按照方法可以大致看出来，每当x0前进，第一pk应力就会减少。反之亦然。

然后算hessian 矩阵
$$
\delta \bold H = - W (\delta \bold P)\bold D_m^{-T} \qquad \frac{\partial \bold H}{\partial x_0} = 33/2 \qquad \frac{\partial \bold H}{\partial x_1} = -33/2
$$
这里的dD, dF, dE, dP, dH 都是2x1x1x1 的四阶张量。接下来就要用这个组装矩阵了。每次我们填一列，用到一个1x1矩阵。但问题是，我们有两个顶点，每个顶点都是一维的，因此两个顶点乘以一维得二，所以我们的K矩阵有2行两列，但我们只能用一个1x1矩阵，怎么办？

这里我其实不太解释得清楚，但应该是这样写
$$
\delta \vec f_1 = \delta \vec h_0 = \frac{\partial \bold H}{\partial  x_0} = 33/2\qquad \delta \vec f_0 = -\delta \vec h_0 = -33/2 \qquad \bold K = \begin{bmatrix} -33/2 & * \\ 33/2 & *\end{bmatrix}
$$
最后填充如下，如果读者有丰富的数值模拟经验，就能发现K矩阵不同寻常的地方，这里的主对角线元素竟然是负的。
$$
\bold K = \begin{bmatrix} -33/2 & 33/2\\ 33/2 & -33/2\end{bmatrix}
$$
简单起见，假设dt = 1, 质量为1，那么
$$
\bold A \Delta \bold x = (\bold  M - \bold K dt^2)\Delta \bold x =\Delta t \bold f
$$
写出来激素
$$
(\begin{bmatrix} 1 & 0 \\ 0 & 1\end{bmatrix} - \begin{bmatrix} -33/2 & 33/2\\ 33/2 & -33/2\end{bmatrix})\begin{bmatrix} \Delta x_0 \\ \Delta x_1\end{bmatrix} = \begin{bmatrix}45/8 \\ -45/8\end{bmatrix}
$$
最后解的速度的增量就是
$$
\begin{bmatrix} \Delta x_0 \\ \Delta x_1\end{bmatrix} = \begin{bmatrix} 0.165\\ -0.165\end{bmatrix}
$$
坐稳了，接下来我们推导二维的隐式方法。芜湖！

## 二维隐式

仍然假设三角形三个点初始位置，以及Dm如下
$$
\bold x_0 = \begin{bmatrix} 0 \\ 0\end{bmatrix} \qquad \bold x_1 = \begin{bmatrix} 1 \\ 0\end{bmatrix} \qquad \bold x_2 = \begin{bmatrix} 0 \\ 1\end{bmatrix} \qquad
$$
那么Dm如下
$$
\bold D_m = \begin{bmatrix} \bold x_1 - \bold x_0 \,|\, \bold  x_2 - \bold x_0\end{bmatrix} = \begin{bmatrix} 1 & 0 \\ 0 & 1\end{bmatrix}
$$
现在假设三角形三个顶点移动到如下位置
$$
\bold x_0 = \begin{bmatrix} 0 \\ 0\end{bmatrix} \qquad \bold x_1 = \begin{bmatrix} 2 \\ 0\end{bmatrix} \qquad \bold x_2 = \begin{bmatrix} 0 \\ 1\end{bmatrix} \qquad
$$
那么Ds以及变形梯度为
$$
\bold D_s = \begin{bmatrix} \bold x_1 - \bold x_0 \,|\, \bold  x_2 - \bold x_0\end{bmatrix} = \begin{bmatrix} 2 & 0 \\ 0 & 1\end{bmatrix} \qquad \bold F = \bold D_s \bold D_m^{-1} = \begin{bmatrix} 2 & 0 \\ 0 & 1\end{bmatrix}
$$
格林应变和第一pk应力如下，仍然假设mu = 2, lambda = 2
$$
\bold E = (\bold F^T \bold F - \bold I)/2 = \begin{bmatrix} 3/2 & 0 \\ 0 & 0\end{bmatrix} \qquad \bold P = \bold F(2\mu \bold E + \lambda tr(\bold E)\bold I) = \begin{bmatrix} 18 & 0 \\ 0 & 3\end{bmatrix}
$$
并且hessian 矩阵
$$
\bold H = - area \bold P(\bold F)\bold D_m^{-T} = \begin{bmatrix} -9 & 0 \\ 0 & -3/2\end{bmatrix}
$$
那么可以计算三个节点力
$$
\vec f_1 = \begin{bmatrix} -9 \\ 0 \end{bmatrix} \qquad \vec f_2 = \begin{bmatrix} 0 \\ -3/2 \end{bmatrix} \qquad \vec f_0 = - \vec f_1 - \vec f_2 = \begin{bmatrix} 9 \\ 3/2\end{bmatrix}
$$
稍微判断一下就知道算出是正确的，因为现在三角形面积变得比初始面积大，所以内能就要想着缩小面积。那么第零个节点，也就是左下角那个节点，开始向右上角移动。其它同理。然后开始求导

此时的dD是3x2x2x2的四阶张量。

注意
$$
\bold D_s = [\bold x_1 - \bold x_0 \quad |\quad  \bold x_2 - \bold x_0]
$$
如果我们重新划分一下现在的顶点位置
$$
\bold x = \begin{bmatrix} \bold x_0 \\ \bold x_1 \\ \bold x_2 \end{bmatrix} = \begin{bmatrix} x_0 \\  x_1 \\  x_2 \\ .. \\ x_5 \end{bmatrix} \quad \bold x_0 = \begin{bmatrix} x_0 \\ x_1 \end{bmatrix}\quad \bold x_1 = \begin{bmatrix} x_2 \\ x_3 \end{bmatrix}\quad \bold x_2 = \begin{bmatrix} x_4 \\ x_5 \end{bmatrix}
$$
因此我们可以很方便得求导这个3x2x2x2的张量
$$
\frac{\partial \bold D_s}{\partial x _0} = \begin{bmatrix} -1 & - 1 \\ 0 & 0\end{bmatrix} \qquad \frac{\partial \bold D_s}{\partial x _1} = \begin{bmatrix} 0 & 0 \\ -1 & -1\end{bmatrix} \\
\frac{\partial \bold D_s}{\partial x _2} = \begin{bmatrix} 1 & 0 \\ 0 & 0\end{bmatrix} \qquad \frac{\partial \bold D_s}{\partial x _3} = \begin{bmatrix} 0 &  0 \\ 1 & 0\end{bmatrix} \\
\frac{\partial \bold D_s}{\partial x _4} = \begin{bmatrix} 0 & 1 \\ 0 & 0\end{bmatrix} \qquad \frac{\partial \bold D_s}{\partial x _5} = \begin{bmatrix} 0 & 0 \\ 0 & 1\end{bmatrix}
$$
如果你对上面感到困惑不解，那么请回忆
$$
\bold D_s = \begin{bmatrix} x_2 - x_0 & x_4 - x_0\\ x_3 - x_1 & x_5 - x_1\end{bmatrix}
$$
既然dD 是 4阶张量有24个数字，那么dF 也是一样是四阶张量有24个数字。此时的dF 与dD的数值是一样的
$$
\frac{\partial \bold F}{\partial x _0} = \begin{bmatrix} -1 & - 1 \\ 0 & 0\end{bmatrix} \qquad \frac{\partial \bold F}{\partial x _1} = \begin{bmatrix} 0 & 0 \\ -1 & -1\end{bmatrix} \\
\frac{\partial \bold F}{\partial x _2} = \begin{bmatrix} 1 & 0 \\ 0 & 0\end{bmatrix} \qquad \frac{\partial \bold F}{\partial x _3} = \begin{bmatrix} 0 &  0 \\ 1 & 0\end{bmatrix} \\
\frac{\partial \bold F}{\partial x _4} = \begin{bmatrix} 0 & 1 \\ 0 & 0\end{bmatrix} \qquad \frac{\partial \bold F}{\partial x _5} = \begin{bmatrix} 0 & 0 \\ 0 & 1\end{bmatrix}
$$
不过我觉得写出这样不好理解，因为变形梯度本来只是一个2x2矩阵，那么对x012345求导，本应该是矩阵中的每个元素对x012345求导，这样的物理就很好理解，如果x2 减去1，也就是最右边那个顶点的x坐标减去一，那么变形梯度就正好变成了单位矩阵，如下
$$
\hat {\bold F} = \bold F - (\Delta x_2 = 1)\frac{\partial \bold F}{\partial x_2} =\begin{bmatrix} 2 & 0 \\ 0 & 1\end{bmatrix} - \begin{bmatrix} 1 & 0 \\ 0 & 0\end{bmatrix} 
$$
但现在这样写，求导完的结果在上面的式子却被分散在6个矩阵了。所以在DynamicDeformables这篇文章所附代码中，是这样写的
$$
\bold d = \bold D_m^{-1} = \begin{bmatrix}d_{00} & d_{01} \\ d_{10} & d_{11} \end{bmatrix}= \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}
$$

$$
\frac{\partial \bold F}{\partial \bold x} = \begin{bmatrix} -d_{00}-d_{01} & 0  & d_{00} & 0 & d_{01} & 0 \\ 0 &  -d_{00}-d_{01} & 0 & d_{00} & 0 & d_{01} \\ -d_{10}-d_{11} & 0 & d_{10} & 0 & d_{11} & 0 \\ 0 &  -d_{10}-d_{11} & 0 & d_{10} & 0 & d_{11}\end{bmatrix}
$$

代码请见https://graphics.pixar.com/library/DynamicDeformablesSiggraph2020/code.zip。其结果和上面的是一样的。第一列对应dFdx0，第二列对应dFdx1，以此类推。
$$
\frac{\partial \bold E}{\partial x _0} = \begin{bmatrix} -2 & - 1 \\ -1 & 0\end{bmatrix} \qquad \frac{\partial \bold E}{\partial x _1} = \begin{bmatrix} 0 & -0.5 \\ -0.5 & -1\end{bmatrix} \\
\frac{\partial \bold E}{\partial x _2} = \begin{bmatrix} 2 & 0 \\ 0 & 0\end{bmatrix} \qquad \frac{\partial \bold E}{\partial x _3} = \begin{bmatrix} 0 &  0.5 \\ 0.5 & 0\end{bmatrix} \\
\frac{\partial \bold E}{\partial x _4} = \begin{bmatrix} 0 & 1 \\ 1 & 0\end{bmatrix} \qquad \frac{\partial \bold E}{\partial x _5} = \begin{bmatrix} 0 & 0 \\ 0 & 1\end{bmatrix}
$$
现在应变求导，但应变与位移并非线性关系，所以如果像刚才那样直接怼一阶导就会有误差。不过仔细观察大体上还能观察出来，那么就是这些矩阵相加的结果是零矩阵。然后dP没什么好写的，用调试器自己去看吧。不过得说说dH
$$
\frac{\partial \bold H}{\partial x _0} = \begin{bmatrix} 16.5 & 5.5 \\ 2 & 2\end{bmatrix} \qquad \frac{\partial \bold H}{\partial x _1} = \begin{bmatrix} 2 & 2 \\ 5.5 & 4.5\end{bmatrix} \\
\frac{\partial \bold H}{\partial x _2} = \begin{bmatrix} -16.5 & 0 \\ 0 & -2\end{bmatrix} \qquad \frac{\partial \bold H}{\partial x _3} = \begin{bmatrix} 0 &  -2 \\ -5.5 & 0\end{bmatrix} \\
\frac{\partial \bold H}{\partial x _4} = \begin{bmatrix} 0 & -5.5 \\ -2 & 0\end{bmatrix} \qquad \frac{\partial \bold H}{\partial x _5} = \begin{bmatrix} -2 & 0 \\ 0 & -4.5\end{bmatrix}
$$
继续仔细观察这些矩阵。你能发现什么？因为如果自己不仔细观察的话，也没有那本书会教我怎么观察。嗯，那些教科书都是堆砌公式罢了。首先，hessian矩阵对顶点求导，所有元素相加的和仍然是零。其次，第一个矩阵的第一个元素是16.5，这和一维隐式的结果是一样的。

继续回想我们的三角形，最右边那个顶点，如果在x轴的坐标减一，那么Hessian矩阵中所有数值将减去dHdx2，也就是将加上一个正数。而Hessian矩阵长这个样子
$$
\bold H = - area \bold P(\bold F)\bold D_m^{-T} = \begin{bmatrix} -9 & 0 \\ 0 & -3/2\end{bmatrix}
$$
所以Hessian矩阵将继续接近零矩阵或单位矩阵。说明求导的方向是对的。而如果最上面那个顶点在x轴移动，也就是增加减少dHdx4，那么并无助于把hessian矩阵变成零矩阵和单位矩阵，这么一想也是合理的，因为上面的顶点在x移动时并不改变三角形的面积。而如果在y轴减去一个正数，也就是让原hessian矩阵减去dHdx5，那么原hessian矩阵也会更加接近零矩阵或单位矩阵，这样也是合理的，因为这样缩小了面积，让面积更接近初始的面积。

现在需要将这些3x2x2x2的四阶张量填到矩阵K中，仍然每次一列，每次使用一个2x2矩阵即可。

哈哈成功了，完整代码如下

```
import numpy as np
# 初始化三角形初始位置
node_pos = np.array([[0,0],[1,0],[0,1]],dtype = float)
# 顶点的位置梯度
Ds = np.array([[node_pos[1,0] - node_pos[0,0],node_pos[2,0] -
node_pos[0,0]],
[node_pos[1,1] - node_pos[0,1],node_pos[2,1] -
node_pos[0,1]]])
# 求逆，用于准备计算形变梯度
minv = np.linalg.inv(Ds)
# 假设某一时刻，三角形变化到了这样的位置
node_pos = np.array([[0,0],[2,0],[0,1]],dtype = float)
node_vel = np.zeros((3,2))
node_force = np.zeros((3,2))
time = 0
timeFinal = 100
areat = np.zeros((timeFinal))
while(time < timeFinal):

    
    node_force[:,:] = 0
    
    time += 1
    # 形变梯度中的分子
    Ds_new = np.array([[node_pos[1,0] - node_pos[0,0],node_pos[2,0]
    - node_pos[0,0]],
    [node_pos[1,1] - node_pos[0,1],node_pos[2,1] -
    node_pos[0,1]]])
    # 形变梯度
    F = np.dot(Ds_new,minv)
    # Green Strain，也就是E
    E = (np.dot(F.T,F)- np.identity(2)) * 0.5
    # lame常数
    mu = 2
    # lame常数
    la = 2
    # 应力
    piola = np.dot(F, 2 * mu * E + la * (E[0,0] + E[1,1]) * np.identity(2))
    
    area = 0.5
    doubleInner = E[0,0]*E[0,0] + E[1,0]*E[1,0] + E[0,1]*E[0,1] + E[1,1]*E[1,1]
    energy = doubleInner * mu + la / 2 * (E[0,0] + E[1,1])**2
    
    H = - area * np.dot(piola,minv.transpose())
    
    gradC0 = np.array([H[0,0],H[1,0]])
    gradC1 = np.array([H[0,1],H[1,1]])
    gradC2 = - gradC0 - gradC1
    
    node_force[0,:] += gradC2
    node_force[1,:] += gradC0
    node_force[2,:] += gradC1
    
    dD = np.zeros((6,2,2))
    dD[0,:,:] = np.array([[-1,-1],[0,0]])
    dD[1,:,:] = np.array([[0,0],[-1,-1]])
    dD[2,:,:] = np.array([[1,0],[0,0]])
    dD[3,:,:] = np.array([[0,0],[1,0]])
    dD[4,:,:] = np.array([[0,1],[0,0]])
    dD[5,:,:] = np.array([[0,0],[0,1]])
    # 变形梯度求导
    dF = np.zeros((6,2,2))
    # Green 应变求导
    dE = np.zeros((6,2,2))
    # piola 求导
    dP = np.zeros((6,2,2))
    # Hessian 求导
    dH = np.zeros((6,2,2))
    for i in range(6):
        dF[i,:,:] = np.dot(dD[i,:,:],minv) 
        d_F = dF[i,:,:]
        dE[i,:,:] = (np.dot(d_F.T,F) + np.dot(F.T,d_F))*0.5
        d_E = dE[i,:,:]
        dP[i,:,:] = np.dot(d_F,2 * mu * E + la * (E[0,0] + E[1,1]) * np.identity(2))
        dP[i,:,:] += np.dot(F,2 * mu * d_E + la * (d_E[0,0] + d_E[1,1]) * np.identity(2))
        dH[i,:,:] = - area * np.dot(dP[i,:,:],minv.T)
    
    K = np.zeros((6,6))
    # 3 个顶点
    for n in range(3):
        # 2 个维度
        for d in range(2):
            # 第 idx 列，每列3 x 2 个元素
            idx = n * 2 + d
            # 先填写第一第二个顶点，第零个顶点之后填
            K[2,idx] = dH[idx,0,0]
            K[3,idx] = dH[idx,1,0]
            K[4,idx] = dH[idx,0,1]
            K[5,idx] = dH[idx,1,1]
            
            K[0,idx] = - dH[idx,0,0] - dH[idx,0,1]
            K[1,idx] = - dH[idx,1,0] - dH[idx,1,1]
            
    mass = 1
    dt = 10
    A = mass * np.identity(6) -  K  * dt * dt
    b = np.zeros((6))
    for n in range(3):
        for d in range(2):
            b[n*2+d] = mass * node_vel[n,d] + dt * node_force[n,d]
            
    x = np.dot(np.linalg.inv(A), b)
    for n in range(3):
        for d in range(2):
            node_vel[n,d] = x[n*2+d] 
            # node_vel[n,d] += node_force[n,d] / mass * dt
            node_pos[n,d] += node_vel[n,d]*dt
            
    areat[time - 1] = 0.5 * (node_pos[0,0] * (node_pos[1,1] - node_pos[2,1])
                    + node_pos[1,0] * (node_pos[2,1] - node_pos[0,1]) 
                    + node_pos[2,0] * (node_pos[0,1] - node_pos[1,1]))
```

可以看到尽管时间步长取得很大，但仍然仅花了两次迭代就几乎完全恢复了原来的形状。 不过有几个缺点，就是时间步长不能取得太小，质量也不能太大太小，否则就无法收敛。原因未知。

