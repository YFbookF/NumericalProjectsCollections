三维三角形

pielet

# Stvk

batels 的 q就是piola



wangdme

```
		// StVK
	//	dEdI	+= stiffness_0*(I-3)*0.25-stiffness_1*0.5;
	//	dEdII	+= stiffness_1*0.25;
	//	dEdIII	+= 0;
	//	H[0][0]	+= stiffness_0*0.25;
	//	energy-=stiffness_0*(I-3)*(I-3)*0.125+stiffness_1*(II-2*I+3)*0.25;
```

===============quasi

```
deltaF = dFdF(i, j);
				deltaE = 0.5 * (deltaF.transpose() * F + F.transpose() * deltaF);

				dPdF(i, j) = deltaF * (2 * m_mu * E + m_lambda * E.trace() * EigenMatrix3::Identity()) + F * (2 * m_mu * deltaE + m_lambda*deltaE.trace()*EigenMatrix3::Identity());
				if (J < 1)
				{
					ScalarType one_minus_J_over_six = (1 - J) / 6.0;
					ScalarType one_minus_J_over_six_square = one_minus_J_over_six*one_minus_J_over_six;

					dPdF(i, j) += -m_kappa / 24 * ((-one_minus_J_over_six*J / 3 + one_minus_J_over_six_square)*J*(Finv*deltaF).trace()*FinvT - one_minus_J_over_six_square*J*FinvT*deltaF.transpose()*FinvT);
				}
```



# Neohookean

重量级的pixar公司的稳定的neohookean模型

http://abaqus.software.polimi.it/v6.14/books/stm/default.htm?startat=ch04s06ath123.html

![image-20211220205818496](E:\mycode\collection\新教程\image-20211220205818496.png)

===========Stable Neo-Hookean Flesh Simulation  

![image-20211219140333066](E:\mycode\collection\新教程\image-20211219140333066.png)

![image-20211219140526092](E:\mycode\collection\新教程\image-20211219140526092.png)



![image-20211219142230824](E:\mycode\collection\新教程\image-20211219142230824.png)
$$
\Psi_{new} = \frac{\mu}{2}(I_C -3) + \frac{\lambda}{2}(J -\alpha)^2 - \frac{\mu}{2}\log(I_C + 1)
$$
但代码中的模型为下
$$
\Psi = \frac{\mu}{2}(I_C - 3) + \frac{\lambda}{2}(J-1- \frac{\mu}{\lambda})^2 \qquad \bold P(\bold F) = \mu \bold F + \lambda (J - 1 - \frac{\mu}{\lambda})\frac{\partial J}{\partial F}
$$



```
static Matrix3 PartialJpartialF(const Matrix3& F)
{
    Matrix3 pJpF;

    pJpF.col(0) = F.col(1).cross(F.col(2));
    pJpF.col(1) = F.col(2).cross(F.col(0));
    pJpF.col(2) = F.col(0).cross(F.col(1));

    return pJpF;
}
```

来检查一下，当处于未变形状态
$$
\bold F = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1\end{bmatrix} \qquad I_C = 3 \qquad J = 1 \qquad \Psi = 0 \qquad \bold P = \begin{bmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0\end{bmatrix}
$$
反向
$$
\bold F = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1\end{bmatrix} \qquad I_C = 3 \qquad J = 1 \qquad \Psi = 0 \qquad \bold P = \begin{bmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0\end{bmatrix}
$$
压缩成面
$$
\bold F = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 0\end{bmatrix} \qquad I_C = 2 \qquad J = 0 \qquad \Psi = 0 \qquad \bold P = \begin{bmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0\end{bmatrix}
$$


在IGsim库中，neohookean模型是这么实现的

include\IGsim\neohookean_model.cpp

```
double I1 = F.squaredNorm();
double J = F.determinant();
double logJ = log(J);

energy = 0.5 * Mu * (I1 - 2 * logJ - 3) + 0.5 * Lam * logJ * logJ;
demu = 0.5 * (I1 - 2 * logJ - 3); 
delam = 0.5 * logJ * logJ;

DerivedF FinvT = F.inverse().transpose();
P = Mu * (F - FinvT) + Lam * logJ * FinvT;
dPmu = F - FinvT;
dPlam = logJ * FinvT;
```

其隐式积分技巧也很独特，虽然没有全部展开，但是也做了很多化简

```
/* accumulate stiffness matrix */
double a = W(i) * Mu(i);
double J = F.determinant();
double b = W(i) * (Mu(i) - Lam(i) * std::log(J));
double c = W(i) * Lam(i);

Mat3 A = Bm[i] * Bm[i].transpose();
Mat3 B = Ds_t.inverse();

double H[12][12];
/* \par H_kl / \par D_sj = a \delta{s, k} A_jl + b B_kj B_sl + c B_sj B_kl */

for (int l = 0; l < 3; l++)
    for (int k = 0; k < 3; k++)
       for (int j = 0; j < 3; j++)
          for (int s = 0; s < 3; s++)
            H[3 * l + k][3 * j + s] = b * B(k, j) * B(s, l) + c * B(s, j) * B(k, l);

for (int l = 0; l < 3; l++)
     for (int s = 0; s < 3; s++)
       for (int j = 0; j < 3; j++)
          H[3 * l + s][3 * j + s] += a * A(j, l);
```

bartels有简化版的

src\psi_neohookean_F.cpp

```
// using Scalar = typename DefoType::Scalar;
    // Scalar detF = F.determinant();
    // Scalar J23 = stablePow(detF,2.0);
    // J23=1.0/J23;
    // Eigen::Matrix<Scalar, 3,3> Cbar = J23*F.transpose()*F;
    
    // return params(0)*(Cbar.trace() - 3.0) + params(1)*(detF - 1)*(detF - 1);

return params1*(log(F1_1*F2_2*F3_3-F1_1*F2_3*F3_2-F1_2*F2_1*F3_3+F1_2*F2_3*F3_1+F1_3*F2_1*F3_2-F1_3*F2_2*F3_1)*-2.0+F1_1*F1_1+F1_2*F1_2+F1_3*F1_3+F2_1*F2_1+F2_2*F2_2+F2_3*F2_3+F3_1*F3_1+F3_2*F3_2+F3_3*F3_3-3.0)+params2*pow(-F1_1*F2_2*F3_3+F1_1*F2_3*F3_2+F1_2*F2_1*F3_3-F1_2*F2_3*F3_1-F1_3*F2_1*F3_2+F1_3*F2_2*F3_1+1.0,2.0);
```

IPC

```
template <int dim>
void NeoHookeanEnergy<dim>::compute_dE_div_dF(const Eigen::Matrix<double, dim, dim>& F,
    const AutoFlipSVD<Eigen::Matrix<double, dim, dim>>& svd,
    double u, double lambda,
    Eigen::Matrix<double, dim, dim>& dE_div_dF) const
{
    if (u == 0.0 && lambda == 0.0) {
        dE_div_dF.setZero();
        return;
    }

    const double J = svd.singularValues().prod();
    Eigen::Matrix<double, dim, dim> FInvT;
    IglUtils::computeCofactorMtr(F, FInvT);
    FInvT /= J;
    dE_div_dF = u * (F - FInvT) + lambda * std::log(J) * FInvT;
}
```



dEnergy_div_sigma

```
    const double inv0 = 1.0 / singularValues[0];
    dE_div_dsigma[0] = u * (singularValues[0] - inv0) + lambda * inv0 * log_sigmaProd;
    const double inv1 = 1.0 / singularValues[1];
    dE_div_dsigma[1] = u * (singularValues[1] - inv1) + lambda * inv1 * log_sigmaProd;
    if constexpr (dim == 3) {
        const double inv2 = 1.0 / singularValues[2];
        dE_div_dsigma[2] = u * (singularValues[2] - inv2) + lambda * inv2 * log_sigmaProd;
    }
    
    const double log_sigmaProd = std::log(singularValues.prod());

    const double inv2_0 = 1.0 / singularValues[0] / singularValues[0];
    d2E_div_dsigma2(0, 0) = u * (1.0 + inv2_0) - lambda * inv2_0 * (log_sigmaProd - 1.0);
    const double inv2_1 = 1.0 / singularValues[1] / singularValues[1];
    d2E_div_dsigma2(1, 1) = u * (1.0 + inv2_1) - lambda * inv2_1 * (log_sigmaProd - 1.0);
    d2E_div_dsigma2(0, 1) = d2E_div_dsigma2(1, 0) = lambda / singularValues[0] / singularValues[1];
    if constexpr (dim == 3) {
        const double inv2_2 = 1.0 / singularValues[2] / singularValues[2];
        d2E_div_dsigma2(2, 2) = u * (1.0 + inv2_2) - lambda * inv2_2 * (log_sigmaProd - 1.0);
        d2E_div_dsigma2(1, 2) = d2E_div_dsigma2(2, 1) = lambda / singularValues[1] / singularValues[2];
        d2E_div_dsigma2(2, 0) = d2E_div_dsigma2(0, 2) = lambda / singularValues[2] / singularValues[0];
    }
```

===============wangdme

```
		//Neo-Hookean
    	dEdI	+= rcbrt_III*stiffness_0;
    	dEdII	+= 0;
    	dEdIII	+= -factor_1*stiffness_0*I;
    	H[0][2]	+= -factor_1*stiffness_0;
    	H[2][2]	+=  factor_2*stiffness_0*I*4;
     
		energy=-(stiffness_0*(I *rcbrt_III-3) + stiffness_1*(J-1)*(J-1));
```

==================

E:\mycode\collection\ANewCollection\Energy\EnergyHessJacbian\zeno_stable_isotropic_NH.h

```
    void ComputePhiDerivHessian(const Mat3x3d& activation,
            const Vec3d& aniso_weight,const Mat3x3d& fiber_direction,const FEM_Scaler& YoungModulus,const FEM_Scaler& PossonRatio,
            const Mat3x3d &F,FEM_Scaler& energy,Vec9d &derivative, Mat9x9d &Hessian,bool enforcing_spd = true) const override {

        Mat3x3d ActInv = activation.inverse();
        Mat3x3d FAct = F * ActInv;

        FEM_Scaler mu = Enu2Mu(YoungModulus,PossonRatio);
        FEM_Scaler lambda = Enu2Lambda(YoungModulus,PossonRatio);

        Vec3d Is;
        std::array<Vec9d,3> gs;
        EvalIsoInvarientsDeriv(FAct,Is,gs);

        eval_phi(lambda,mu,Is,energy);

        Vec3d dphi;
        eval_dphi(lambda,mu,Is,dphi);


        Mat9x9d dFactdF = EvaldFactdF(ActInv); 

        derivative = dphi[0] * gs[0] + dphi[1] * gs[1] + dphi[2] * gs[2];     
        derivative = dFactdF.transpose() * derivative;

        Vec9d eigen_vecs[9];
        Vec9d eigen_vals;
            
        // compute the eigen system of Hessian
        ComputeIsoEigenSystem(YoungModulus,PossonRatio, FAct, eigen_vals, eigen_vecs);  
        if (enforcing_spd) {
            for (size_t i = 0; i < 9; ++i)
                eigen_vals[i] = eigen_vals[i] > 1e-12 ? eigen_vals[i] : 1e-12;
        }
        Hessian.setZero();
        for(size_t i = 0;i < 9;++i){
            Hessian += eigen_vals[i] * eigen_vecs[i] * eigen_vecs[i].transpose();
        }

        Hessian = dFactdF.transpose() * Hessian * dFactdF; 
    }

```

=================

fabsim

https://github.com/DavidJourdan/fabsim

E:\mycode\collection\ANewCollection\elasticPlastic\stvkModeletc\basim_NeoHookeanElement.cpp

```
Eigen::Matrix2d NeoHookeanElement::stress(const Eigen::Ref<const Eigen::VectorXd> X, double lambda, double mu) const
{
  using namespace Eigen;

  Matrix<double, 3, 2> F = deformationGradient(X);
  Matrix2d C = F.transpose() * F;
  double lnJ = log(C.determinant()) / 2;

  return mu * Matrix2d::Identity() + (lambda * lnJ - mu) * C.inverse();
}
```

============================

```
#ifdef LOGJ_QUADRATIC_EXTENSION
					// quadratic
					ScalarType fJ = log(J0) + (J - J0) / J0 - 0.5*std::pow((J / J0 - 1), 2);
					ScalarType dfJdJ = 1.0 / J0 - (J - J0) / (J0*J0);
					ScalarType d2fJdJ2 = -1.0 / (J0*J0);
#else
					ScalarType fJ = log(J0) + (J - J0) / J0;
					ScalarType dfJdJ = 1.0 / J0;
					ScalarType d2fJdJ2 = 0;
#endif
					EigenMatrix3 FinvTdFTFinvT = FinvT*deltaF.transpose()*FinvT;
					EigenMatrix3 FinvdFtraceFinvT = (Finv*deltaF).trace() * FinvT;

					dPdF(i, j) += -m_mu * (d2fJdJ2*J + dfJdJ) * J * FinvdFtraceFinvT;
					dPdF(i, j) += m_mu * (dfJdJ*J) * FinvTdFTFinvT;
					dPdF(i, j) += m_lambda * (dfJdJ*dfJdJ*J + fJ*(d2fJdJ2*J + dfJdJ)) * J * FinvdFtraceFinvT;
					dPdF(i, j) += -m_lambda * (fJ*dfJdJ*J) * FinvTdFTFinvT;
```

=============================polyfem

```
			const Eigen::MatrixXd def_grad = Eigen::MatrixXd::Identity(size(), size()) + displacement_grad;
			const Eigen::MatrixXd FmT = def_grad.inverse().transpose();
			// const double J = def_grad.determinant();

			double lambda, mu;
			params_.lambda_mu(vals.val(p, 0), vals.val(p, 1), size_ == 2 ? 0. : vals.val(p, 2), vals.element_id, lambda, mu);

			//stress = mu (F - F^{-T}) + lambda ln J F^{-T}
			//stress = mu * (def_grad - def_grad^{-T}) + lambda ln (det def_grad) def_grad^{-T}
			Eigen::MatrixXd stress_tensor = mu * (def_grad - FmT) + lambda * std::log(def_grad.determinant()) * FmT;

			//stess = (mu displacement_grad + lambda ln(J) I)/J
			// Eigen::MatrixXd stress_tensor = (mu_/J) * displacement_grad + (lambda_/J) * std::log(J)  * Eigen::MatrixXd::Identity(size(), size());

```

==============ziran

```
    if constexpr (dim == 2) {
        T sigma_prod = s.sigma.prod();
        T log_sigmaProd = std::log(sigma_prod);
        T inv0 = T(1) / s.sigma(0);
        T inv1 = T(1) / s.sigma(1);

        s.isotropic.psi0 = mu * (s.sigma(0) - inv0) + lambda * inv0 * log_sigmaProd;
        s.isotropic.psi1 = mu * (s.sigma(1) - inv1) + lambda * inv1 * log_sigmaProd;

        T inv2_0 = T(1) / s.sigma(0) / s.sigma(0);
        T inv2_1 = T(1) / s.sigma(1) / s.sigma(1);

        s.isotropic.psi00 = mu * (T(1) + inv2_0) - lambda * inv2_0 * (log_sigmaProd - T(1));
        s.isotropic.psi11 = mu * (T(1) + inv2_1) - lambda * inv2_1 * (log_sigmaProd - T(1));
        s.isotropic.psi01 = lambda / s.sigma(0) / s.sigma(1);

        // (psi0-psi1)/(sigma0-sigma1)

        s.isotropic.m01 = mu + (mu - lambda * log_sigmaProd) / sigma_prod;

        // (psi0+psi1)/(sigma0+sigma1)
        s.isotropic.p01 = (s.isotropic.psi0 + s.isotropic.psi1) / clamp_small_magnitude(s.sigma(0) + s.sigma(1), eps);

        if (project) {
            s.isotropic.buildMatrixBlock();
            s.isotropic.projectABBlock();
        }
```

===============vegafem

```
void NeoHookeanIsotropicMaterial::ComputeEnergyGradient(int elementIndex, double * invariants, double * gradient) // invariants and gradient are 3-vectors
{
  //printf("Entered NeoHookeanIsotropicMaterial::ComputeEnergyGradient\n");

  double IIIC = invariants[2];
  gradient[0] = 0.5 * muLame[elementIndex];
  gradient[1] = 0.0;
  gradient[2] = (-0.5 * muLame[elementIndex] + 0.25 * lambdaLame[elementIndex] * log(IIIC)) / IIIC;

  AddCompressionResistanceGradient(elementIndex, invariants, gradient);
}
```

=========================

D:\图形学书籍\图形学书籍\有限元\非线性专项\Nonlinear Continuum Mechanics for Finite Element Analysis, 2nd Edition by Javier Bonet, Richard D. Wood (z-lib.org).pdf

![image-20211220094910497](E:\mycode\collection\新教程\image-20211220094910497.png)

![image-20211220095036203](E:\mycode\collection\新教程\image-20211220095036203.png)

# Fiber

bartels\src\psi_muscle_fiber_F.cpp

```
return 0.5*params(0)*direction.transpose()*(F.transpose()*F)*direction;
```



# Stretch

bartels 库里有这么一段，仅计算拉伸或压缩

src\psi_stretch_F.cpp



```
igl::svd3x3(F_float,U,S,V);

    //evaluate energy
    return static_cast<Scalar>(psi(S,params));
```

奇异值

src\dpsi_stretch_dF.cpp

```
void sim::dpsi_stretch_dF(Eigen::MatrixBase<HessianType> &ddw, const Eigen::MatrixBase<DefoType> &F, DpsiStretchFunc dpsi, const Eigen::MatrixBase<ParameterType> &params) {

    using Scalar = typename HessianType::Scalar;

    Eigen::Vector3x<float> Plam;
    Eigen::Matrix3x<float> F_float, U,V;
    Eigen::Vector3x<float> S;

    F_float = F.template cast<float>();

    igl::svd3x3(F_float,U,S,V);
    
    //Fix for inverted elements (thanks to Danny Kaufman)
    Scalar det = S[0]*S[1]*S[2];
    
    if(det <= -1e-10)
    {
        if(S[0] < 0) S[0] *= -1;
        if(S[1] < 0) S[1] *= -1;
        if(S[2] < 0) S[2] *= -1;
    }
    
    if(U.determinant() <= 0)
    {
        U(0, 2) *= -1;
        U(1, 2) *= -1;
        U(2, 2) *= -1;
    }
    
    if(V.determinant() <= 0)
    {
        V(0, 2) *= -1;
        V(1, 2) *= -1;
        V(2, 2) *= -1;
    }
    
    dpsi(Plam, S, params);
    ddw = (flatten(U*(Plam.asDiagonal()*V.transpose()))).template cast<Scalar>();
                        
}
```

======================abaqus

http://abaqus.software.polimi.it/v6.14/books/stm/default.htm?startat=ch04s06ath123.html

- the polynomial form and its particular cases—the reduced polynomial form, the neo-Hookean form, the Mooney-Rivlin form, and the Yeoh form;
- the Ogden form;

==================

D:\图形学书籍\图形学书籍\有限元\非线性专项\Nonlinear Continuum Mechanics for Finite Element Analysis, 2nd Edition by Javier Bonet, Richard D. Wood (z-lib.org).pdf

![image-20211220095420857](E:\mycode\collection\新教程\image-20211220095420857.png)

# Coratation

src\psi_corotational_S.cpp

bartels

```
return params(1)*((S[0] - 1.) * (S[0] - 1.) + (S[1] - 1.) * (S[1] - 1.) + (S[2] - 1.) * (S[2] - 1.) ) + 0.5*params(0)*(S[0] + S[1] + S[2] - 3.0)*( S[0] + S[1] + S[2] - 3.0);
```

奇异值求导，首先仍然是

```
void sim::dpsi_arap_dS(Eigen::Vector3x<OutputType> &ds, const Eigen::Vector3x<SType>  &S, const Eigen::MatrixBase<ParameterType> &params) {
            
    ds[0] = static_cast<OutputType>(2)*params(0) * (S[0] - static_cast<OutputType>(1));
    ds[1] = static_cast<OutputType>(2)*params(0) * (S[1] - static_cast<OutputType>(1));
    ds[2] = static_cast<OutputType>(2)*params(0) * (S[2] - static_cast<OutputType>(1));
}
```

IPC

E:\mycode\Elastic\IPC-master\src\Energy\Physics_Elasticity\FixedCoRotEnergy.cpp

```
template <int dim>
void FixedCoRotEnergy<dim>::compute_E(const Eigen::Matrix<double, dim, 1>& singularValues,
    double u, double lambda,
    double& E) const
{
    const double sigmam12Sum = (singularValues - Eigen::Matrix<double, dim, 1>::Ones()).squaredNorm();
    const double sigmaProdm1 = singularValues.prod() - 1.0;

    E = u * sigmam12Sum + lambda / 2.0 * sigmaProdm1 * sigmaProdm1;
}
```



```
template <int dim>
void FixedCoRotEnergy<dim>::compute_dE_div_dsigma(const Eigen::Matrix<double, dim, 1>& singularValues,
    double u, double lambda,
    Eigen::Matrix<double, dim, 1>& dE_div_dsigma) const
{
    const double sigmaProdm1lambda = lambda * (singularValues.prod() - 1.0);
    Eigen::Matrix<double, dim, 1> sigmaProd_noI;
    if constexpr (dim == 2) {
        sigmaProd_noI[0] = singularValues[1];
        sigmaProd_noI[1] = singularValues[0];
    }
    else {
        sigmaProd_noI[0] = singularValues[1] * singularValues[2];
        sigmaProd_noI[1] = singularValues[2] * singularValues[0];
        sigmaProd_noI[2] = singularValues[0] * singularValues[1];
    }

    double _2u = u * 2;
    dE_div_dsigma[0] = (_2u * (singularValues[0] - 1.0) + sigmaProd_noI[0] * sigmaProdm1lambda);
    dE_div_dsigma[1] = (_2u * (singularValues[1] - 1.0) + sigmaProd_noI[1] * sigmaProdm1lambda);
    if constexpr (dim == 3) {
        dE_div_dsigma[2] = (_2u * (singularValues[2] - 1.0) + sigmaProd_noI[2] * sigmaProdm1lambda);
    }
}
```

D:\图形学书籍\论文\Stable Neo-Hookean Flesh Simulation.pdf

fixed corotational
$$
\Psi = \mu||\bold F - \bold R||^2_F + \frac{\lambda}{2}(J-1)^2
$$
![image-20211219151826922](E:\mycode\collection\新教程\image-20211219151826922.png)

==================bullet3

```
	void firstPiola(const btMatrix3x3& F, btMatrix3x3& P)
	{
		// btMatrix3x3 JFinvT = F.adjoint();
		btScalar J = F.determinant();
		P = F.adjoint().transpose() * (m_lambda * (J - 1));
		if (m_mu > SIMD_EPSILON)
		{
			btMatrix3x3 R, S;
			if (J < 1024 * SIMD_EPSILON)
				R.setIdentity();
			else
				PolarDecomposition(F, R, S);  // this QR is not robust, consider using implicit shift svd
			/*https://fuchuyuan.github.io/research/svd/paper.pdf*/
			P += (F - R) * 2 * m_mu;
		}
	}
```

===============quasi

```
	case MATERIAL_TYPE_COROT:
	{
		EigenMatrix3 U;
		EigenMatrix3 V;
		EigenVector3 SIGMA;
		singularValueDecomp(U, SIGMA, V, F);

		EigenMatrix3 R = U*V.transpose();

		Matrix3333 dRdF;

		// to compute dRdF using derivative of SVD
		for (unsigned int i = 0; i < 3; i++)
		{
			for (unsigned int j = 0; j < 3; j++)
			{
				EigenMatrix3 deltaF = dFdF(i, j);

				EigenMatrix3 A = U.transpose() * deltaF * V;
```

=====================ziran

```

template <class T, int _dim>
void CorotatedDistortionalDilational<T, _dim>::firstPiolaDifferential(const Scratch& s, const TM& dF, TM& dP) const
{
    using namespace EIGEN_EXT;

    // lambda term
    dP.noalias() = lambda * s.JFinvT.cwiseProduct(dF).sum() * s.JFinvT;
    addScaledCofactorMatrixDifferential(s.F, dF, lambda * (s.J - (T)1), dP);

    // mu term: using notations from the techdoc of [stomakhin2014augmented]
    static const T a = -(T)1 / (T)_dim;
    CorotatedElasticity<T, dim> corotated;
    corotated.mu = mu;
    corotated.lambda = 0;

    TM A;
    corotated.firstPiola(s.corotated_scratch, A);
    TM Z = dF;
    TM H = s.JFinvT / s.J;
    T H_contract_Z = (H.array() * Z.array()).sum();
    TM B_contract_Z = std::pow(s.J, a) * (Z + a * H_contract_Z * s.F);
    TM C_contract_B_contract_Z = TM::Zero();
    corotated.firstPiolaDifferential(s.corotated_scratch, B_contract_Z, C_contract_B_contract_Z);
    T F_contract_C_contract_B_contract_Z = (s.F.array() * C_contract_B_contract_Z.array()).sum();
    dP += std::pow(s.J, a) * (C_contract_B_contract_Z + a * F_contract_C_contract_B_contract_Z * H); // term 1
    T F_contract_A = (s.F.array() * A.array()).sum();
    TM A_contract_B = std::pow(s.J, a) * (A + a * F_contract_A * H);
    dP += a * H_contract_Z * A_contract_B; // term 2
    T A_contract_Z = (A.array() * Z.array()).sum();
    dP += a * std::pow(s.J, a) * A_contract_Z * H; // term 3
    dP += -a * std::pow(s.J, a) * F_contract_A * H * (Z.transpose()) * H; // term 4
}

```



# AsRigidAsPossible

bartels\src\psi_arap_S.cpp

```
return params(0)*((S[0] - static_cast<SType>(1)) * (S[0] - static_cast<SType>(1)) +
                       (S[1] - static_cast<SType>(1)) * (S[1] - static_cast<SType>(1)) +
                       (S[2] - static_cast<SType>(1)) * (S[2] - static_cast<SType>(1)));
```

劳资为什么要整理这么多？

奇异值求导，仍然是

```m
void sim::dpsi_corotational_dS(Eigen::Vector3x<OutputType> &ds, const Eigen::Vector3x<SType>  &S, const Eigen::MatrixBase<ParameterType> &params) {
            
    ds[0] = 2.0*params[1]*(-1.0+S[0])+params[0]*(-3.0+S[0]+S[1]+S[2]);
    ds[1] = 2.0*params[1]*(-1.0+S[1])+params[0]*(-3.0+S[0]+S[1]+S[2]);
    ds[2] = 2.0*params[1]*(-1.0+S[2])+params[0]*(-3.0+S[0]+S[1]+S[2]);

}
```



```
  //     ARAP_ENERGY_TYPE_SPOKES  "As-rigid-as-possible Surface Modeling" by [Sorkine and
  //       Alexa 2007], rotations defined at vertices affecting incident edges,
  //       default
  //     ARAP_ENERGY_TYPE_SPOKES-AND-RIMS  Adapted version of "As-rigid-as-possible Surface
  //       Modeling" by [Sorkine and Alexa 2007] presented in section 4.2 of or
  //       "A simple geometric model for elastic deformation" by [Chao et al.
  //       2010], rotations defined at vertices affecting incident edges and
  //       opposite edges
  //     ARAP_ENERGY_TYPE_ELEMENTS  "A local-global approach to mesh parameterization" by
  //       [Liu et al.  2010] or "A simple geometric model for elastic
  //       deformation" by [Chao et al.  2010], rotations defined at elements
  //       (triangles or tets) 
  //     ARAP_ENERGY_TYPE_DEFAULT  Choose one automatically: spokes and rims
  //       for surfaces, elements for planar meshes and tets (not fully
  //       supported)
  enum ARAPEnergyType
```



# Mooney

https://web.cse.ohio-state.edu/~wang.3602/publications.html

E:\mycode\plastic\SimDesign_SOFA-master\modules\SofaMiscFem\MooneyRivlin.h

```
		// Mooney-Rivlin		
	//	TYPE two_term_a	= stiffness_2*rcbrt_III*I;
	//	TYPE two_term_b	= stiffness_2*rcbrt_III*(I*I-II);
	//	dEdI	+= rcbrt_III*two_term_a;
	//	dEdII	+= -0.5*stiffness_2*rcbrt_III*rcbrt_III;
	//	dEdIII	+= -factor_1*two_term_b;
	//	H[0][0]	+= stiffness_2*rcbrt_III*rcbrt_III;
	//	H[0][2]	+= -factor_1*two_term_a*2;
	//	H[1][2]	+= factor_1*stiffness_2*rcbrt_III;
	//	H[2][2]	+= factor_2*two_term_b*5;
	//	energy-=stiffness_2*(0.5*rcbrt_III*rcbrt_III*(I*I-II)-3);
```

oofem

E:\mycode\collection\ANewCollection\elasticPlastic\stvkModeletc\oofem_mooneyrivlincompressiblematerial.C

```
FloatArrayF< 9 >
MooneyRivlinCompressibleMaterial::giveFirstPKStressVector_3d(const FloatArrayF< 9 > &vF, GaussPoint *gp, TimeStep *tStep) const
// returns 9 components of the first piola kirchhoff stress corresponding to the given deformation gradinet
{
    StructuralMaterialStatus *status = static_cast< StructuralMaterialStatus * >( this->giveStatus(gp) );

    Tensor2_3d F(vF), P;
    // compute the first Piola-Kirchhoff
    P(i_3, j_3) =  C1 * this->compute_dI1_Cdev_dF(F)(i_3, j_3) + C2 * this->compute_dI2_Cdev_dF(F)(i_3, j_3) + this->compute_dVolumetricEnergy_dF(F)(i_3, j_3);
    auto vP = P.to_voigt_form();
    // update gp
    status->letTempFVectorBe(vF);
    status->letTempPVectorBe(vP);
    //
    return vP;
}

```

===========vegafem

```
void MooneyRivlinIsotropicMaterial::ComputeEnergyGradient(int elementIndex, double * invariants, double * gradient) // invariants and gradient are 3-vectors
{
  //printf("Entering MooneyRivlinIsotropicMaterial::ComputeEnergyGradient\n");

  double Ic = invariants[0];
  double IIc = invariants[1];
  double IIIc = invariants[2];

  double mu01 = mu01_[elementIndex];
  double mu10 = mu10_[elementIndex];
  double v1 = v1_[elementIndex];

  gradient[0] = (Ic * mu01) / pow(IIIc, 2.0 / 3.0) + 
    mu10 / pow(IIIc, 1.0 / 3.0);
  gradient[1] = (-0.5 * mu01) / pow(IIIc, 2.0 / 3.0);
  gradient[2] = (-1.0 / 3.0 * (Ic * Ic - IIc) * mu01) / pow(IIIc, 5.0 / 3.0) - 
    (1.0 / 3.0 * Ic * mu10) / pow(IIIc, 4.0 / 3.0) + 
    ((-1.0 + sqrt(IIIc)) * v1) / sqrt(IIIc);

  AddCompressionResistanceGradient(elementIndex, invariants, gradient);
}
```

==================E:\mycode\Elastic\streambox-76f95780d1bf6c02731e39d8ac73937cea352b95\Kaskade\fem\diffops\mooneyRivlin.hh

```
    double rho = g.d1(1)/(-g.d2(1)+g.d1(1));
    double d = (lambda+2.0*mu)/(g.d2(1)-g.d1(1));
    double c = (0.5*rho-0.25)*mu+0.25*rho*lambda;
    if(c > 0.25*mu) c = (rho-0.75)*mu+0.5*rho*lambda;
    double b = -mu + rho*(lambda+2.*mu)-2.*c;
    double a = b + mu;
    double alpha = 0.5*a - b;
    double beta = 0.5*b;
    //    std::cout << "alpha: " << alpha << ", beta: " << beta << ", c: " << c << ", d: " << d << std::endl;
```

============================suanpan-dev

```
	const auto W8 = W5;
	const auto W6 = .5 * W3;
	W1 = two_three * W8;
	W2 *= four_three;
	W3 = .375 * W2;
	W5 = two_three * W4;
	W4 = four_three * W8;
	const auto W7 = .75 * W5;
	const auto W9 = .5 * W8;

	const mat TA = A10 * W1 * J1E + A01 * W4 * J2E;
	const mat TB = TA * J3E.t();

	trial_stiffness = (A10 * W2 + A01 * W5 + K - K * J3M1 * W8) * J3E * J3E.t() + (K * J3M1 * W9 - A10 * W3 - A01 * W7) * I3EE + A01 * W6 * I2EE - TB - TB.t();

	return SUANPAN_SUCCESS;
}
```

D:\图形学书籍\图形学书籍\有限元\非线性专项\Nonlinear Continuum Mechanics for Finite Element Analysis, 2nd Edition by Javier Bonet, Richard D. Wood (z-lib.org).pdf

![image-20211220095102304](E:\mycode\collection\新教程\image-20211220095102304.png)

# Fung

```
	// Fung
	//	TYPE exp_term	= expf(stiffness_3*(rcbrt_III*I-3))*stiffness_2*stiffness_3;
	//	dEdI	+= exp_term*rcbrt_III;
	//	dEdIII	+= -factor_1*I*exp_term;
	//	H[0][0]	+= rcbrt_III*stiffness_3*rcbrt_III*exp_term;
	//	H[0][2]	+= -factor_1*exp_term*(1+stiffness_3*rcbrt_III*I);
	//	H[2][2]	+= factor_2*I*exp_term* (4 + stiffness_3*I*rcbrt_III);
	//	energy-=stiffness_2*(exp(stiffness_3*(rcbrt_III*I-3))-1);
```

# ogden

oofem

E:\mycode\plastic\SimDesign_SOFA-master\modules\SofaMiscFem\MooneyRivlin.h

ployfem

```
const T J = polyfem::determinant(def_grad);
			const T Jdenom = pow(J, -1./size());

			for(long i = 0; i < eigs.size(); ++i)
				eigs(i) = eigs(i) * Jdenom;

			auto val = T(0);
			for(long N = 0; N < alphas_.size(); ++N)
			{
				auto tmp = T(-size());
				const double alpha = alphas_(N);
				const double mu = mus_(N);

				for(long i = 0; i < eigs.size(); ++i)
					tmp += pow(eigs(i), alpha);

				val += 2*mu/(alpha * alpha) * tmp;
			}

			// std::cout<<val<<std::endl;

			for(long N = 0; N < Ds_.size(); ++N)
			{
				const double D = Ds_(N);

				val += 1./D * pow(J - T(1), 2*(N+1));
			}
```

D:\图形学书籍\论文\Descent Methods for Elastic Body Simulation on the GPU.pdf

![image-20211220205759915](E:\mycode\collection\新教程\image-20211220205759915.png)

# Simpister

oofem

# Blaszko

oofem



suanpan-dev

# 黎曼不变量

![image-20211219142432440](E:\mycode\collection\新教程\image-20211219142432440.png)

D:\图形学书籍\图形学书籍\有限元\非线性专项\Nonlinear Continuum Mechanics for Finite Element Analysis, 2nd Edition by Javier Bonet, Richard D. Wood (z-lib.org).pdf

![image-20211220094654079](E:\mycode\collection\新教程\image-20211220094654079.png)

Deformation Embedding for Point-Based Elastoplastic Simulation  

![image-20211222090838863](E:\mycode\collection\新教程\image-20211222090838863.png)

wangdme

```
        TYPE I			= Sigma[0]*Sigma[0]+Sigma[1]*Sigma[1]+Sigma[2]*Sigma[2];
        TYPE J			= Sigma[0]*Sigma[1]*Sigma[2];
        TYPE II			= Sigma[0]*Sigma[0]*Sigma[0]*Sigma[0]+Sigma[1]*Sigma[1]*Sigma[1]*Sigma[1]+Sigma[2]*Sigma[2]*Sigma[2]*Sigma[2];
		TYPE III		= J*J;
		TYPE rcbrt_III	= 1.0/cbrt(III);
```

nonlinear

![image-20211220093822891](E:\mycode\collection\新教程\image-20211220093822891.png)



# 阻尼

IPC

```
if (m_enable_damping)
{
 		grad_f[i] = (1 + h * alpha) * M[i] * v_next[i] - M[i] * u[i] + h * beta * Kv[i] + h * grad_E[i];
 		m_A[i].addInDiagonal(mass, 1 + m_dt * m_damping_alpha);
}else
{
		grad_f[i] = M[i] * (v_next[i] - u[i]) + h * grad_E[i];
		m_A[i].addInDiagonal(mass);
}
```

================Efficient and Accurate Collision Response for Elastically Deformable Models  

![image-20211219134717606](E:\mycode\collection\新教程\image-20211219134717606.png)

=================

bullet3

```
				btMatrix3x3 dF = DsFromVelocity(node0, node1, node2, node3) * tetra.m_Dm_inverse;
				btMatrix3x3 I;
				I.setIdentity();
				btMatrix3x3 dP = (dF + dF.transpose()) * m_mu_damp + I * (dF[0][0] + dF[1][1] + dF[2][2]) * m_lambda_damp;
				//                firstPiolaDampingDifferential(psb->m_tetraScratchesTn[j], dF, dP);
				btVector3 df_on_node0 = dP * (tetra.m_Dm_inverse.transpose() * grad_N_hat_1st_col);
				btMatrix3x3 df_on_node123 = dP * tetra.m_Dm_inverse.transpose();

				// damping force differential
				btScalar scale1 = scale * tetra.m_element_measure;
				force[id0] -= scale1 * df_on_node0;
				force[id1] -= scale1 * df_on_node123.getColumn(0);
				force[id2] -= scale1 * df_on_node123.getColumn(1);
				force[id3] -= scale1 * df_on_node123.getColumn(2);
```



# 奇异值分解技巧

batels库

首先为了防止特征值不唯一

```
    //derivative of SVD wrt to F
    //check multiplicity, small random permutation if eigenvalues not unique
    if(std::fabs(S[0] - S[1]) < 1e-5 || std::fabs(S[1] - S[2]) < 1e-5 || std::fabs(S[0] - S[2]) < 1e-5) {
        F_float += Eigen::Matrix3x<float>::Random()*1e-5;
        igl::svd3x3(F_float,U,S,V);
    }
```

其次奇异值求导

src\dsvd.cpp

```
dsvd(dU, dS, dV, U, S, V);
Eigen::Matrix3x<Scalar> rowMat;
    
for(unsigned int r = 0; r <3; ++r) {
   for(unsigned int s = 0; s<3; ++s) {
      PlamVec  = Plam2*dS[r][s];
      rowMat = (dU[r][s]*Plam.asDiagonal()*V.transpose() + U*Plam.asDiagonal()*dV[r][s].transpose() + U*PlamVec.asDiagonal()*V.transpose()).template cast<Scalar>();
      rowMat.transposeInPlace();
      ddw.row(3*r + s) = Eigen::Map<Eigen::Matrix<Scalar, 1,9> >(rowMat.data(), 9);
```

pielet

E:\mycode\Hair\PieletClothSim\ClothSim\Constraints.cu

```
		// definiteness fix
		Vec9x sigma;
		bool succ = SVDdecomp(U, V, sigma);
		sigma_out[fid] = sigma;
		if (succ)
		{
			//SVDreorder(*U, *V, sigma);

			Scalar smallest_sigma = 1e-6f;
			for (i = 0; i < 9; ++i) sigma(i) = fmax(sigma(i), smallest_sigma);

			Vec9x U_row;
			Scalar sum;
			for (i = 0; i < 9; ++i)
			{
				for (j = 0; j < 9; ++j)
					U_row(j) = U(i, j) * sigma(j);
				for (j = 0; j < 9; ++j)
				{
					sum = 0.0f;
					for (k = 0; k < 9; ++k)
						sum += U_row(k) * V(j, k);
					U(i, j) = sum;
				}
			}
		}

		for (int i = 0; i < 3; ++i) for (int j = 0; j < 3; ++j)
		{
			hess.atomicAddBlock(idx(i), idx(j), U.block<3, 3>(i, j));
		}
```

================Efficient and Accurate Collision Response for Elastically Deformable Models  

![image-20211219134643801](E:\mycode\collection\新教程\image-20211219134643801.png)

=============E:\mycode\Elastic\snh_code\snh_code\cubesim\Cube.cpp

```
static void RotationVariantSVD(const Matrix3& F, Matrix3& U, Matrix3& V, Vector3& S)
{
    const Eigen::JacobiSVD<Matrix3,Eigen::NoQRPreconditioner> svd(F, Eigen::ComputeFullU | Eigen::ComputeFullV);
    U = svd.matrixU();
    V = svd.matrixV();
    S = svd.singularValues();
    if (U.determinant() < 0.0)
    {
        U.col(0) *= -1.0;
        S(0) *= -1.0;
    }
    if (V.determinant() < 0.0)
    {
        V.col(0) *= -1.0;
        S(0) *= -1.0;
    }
}

```

==https://web.cse.ohio-state.edu/~wang.3602/publications.html

```
        if(fabsf(Sigma[0])<fabsf(Sigma[1]) && fabsf(Sigma[0])<fabsf(Sigma[2]))	small_id=0;
        else if(fabsf(Sigma[1])<fabsf(Sigma[2]))                                small_id=1;
        else                                                                    small_id=2;
        if(U[0]*(U[4]*U[8]-U[7]*U[5])+U[3]*(U[7]*U[2]-U[1]*U[8])+U[6]*(U[1]*U[5]-U[4]*U[2])<0)
        {
            U[0+small_id]	=-U[0+small_id];
            U[3+small_id]	=-U[3+small_id];
            U[6+small_id]	=-U[6+small_id];
			Sigma[small_id]	=-Sigma[small_id];
        }
        if(V[0]*(V[4]*V[8]-V[7]*V[5])+V[3]*(V[7]*V[2]-V[1]*V[8])+V[6]*(V[1]*V[5]-V[4]*V[2])<0)
        {
            V[0+small_id]=-V[0+small_id];
            V[3+small_id]=-V[3+small_id];
            V[6+small_id]=-V[6+small_id];
			Sigma[small_id] = -Sigma[small_id];
        }
```

==================bullet3库

```
	void firstPiola(const btMatrix3x3& F, btMatrix3x3& P)
	{
		// btMatrix3x3 JFinvT = F.adjoint();
		btScalar J = F.determinant();
		P = F.adjoint().transpose() * (m_lambda * (J - 1));
		if (m_mu > SIMD_EPSILON)
		{
			btMatrix3x3 R, S;
			if (J < 1024 * SIMD_EPSILON)
				R.setIdentity();
			else
				PolarDecomposition(F, R, S);  // this QR is not robust, consider using implicit shift svd
			/*https://fuchuyuan.github.io/research/svd/paper.pdf*/
			P += (F - R) * 2 * m_mu;
		}
	}

```

E:\mycode\physicsEngine\bullet3-master\src\BulletSoftBody\btDeformableNeoHookeanForce.h

```
#ifdef USE_SVD
				if (max_p > 0)
				{
					// since we want to clamp the principal stress to max_p, we only need to
					// calculate SVD when sigma_0^2 + sigma_1^2 + sigma_2^2 > max_p * max_p
					btScalar trPTP = (P[0].length2() + P[1].length2() + P[2].length2());
					if (trPTP > max_p * max_p)
					{
						btMatrix3x3 U, V;
						btVector3 sigma;
						singularValueDecomposition(P, U, sigma, V);
						sigma[0] = btMin(sigma[0], max_p);
						sigma[1] = btMin(sigma[1], max_p);
						sigma[2] = btMin(sigma[2], max_p);
						sigma[0] = btMax(sigma[0], -max_p);
						sigma[1] = btMax(sigma[1], -max_p);
						sigma[2] = btMax(sigma[2], -max_p);
						btMatrix3x3 Sigma;
						Sigma.setIdentity();
						Sigma[0][0] = sigma[0];
						Sigma[1][1] = sigma[1];
						Sigma[2][2] = sigma[2];
						P = U * Sigma * V.transpose();
					}
				}
#endif
```

====================phybs

https://github.com/Wulonghua/PhyBS

```
/**********see [Teran. 2004], compute F_hat and make sure U,V are real rotation matrix.********/
void IsotropicMaterial::computeSVD33modified(Eigen::Matrix3f F, Eigen::Vector3f &S, Eigen::Matrix3f &U, Eigen::Matrix3f &V)
{
	Eigen::JacobiSVD<Eigen::Matrix3f> svd(F, Eigen::ComputeFullU | Eigen::ComputeFullV);
	S = svd.singularValues();
	//for (int i = 0; i < 3; ++i)
	//	S(i) = m_tetModel->fixPrecision(S(i));
	V = svd.matrixV();

	// Fix V if determinant of V is equal to -1
	if (V.determinant() < 0) // ==-1
	{
		V.col(0) = V.col(0) * (-1);
	}

	Eigen::Matrix3f ss = Eigen::Matrix3f::Zero();
	ss(0, 0) = S(0) > m_eps_singularvalue ? 1 / S(0) : 0.0;
	ss(1, 1) = S(1) > m_eps_singularvalue ? 1 / S(1) : 0.0;
	ss(2, 2) = S(2) > m_eps_singularvalue ? 1 / S(2) : 0.0;

	U = F * V * ss;
	//The returned singular values are already sorted in descending order if use Eigen lib function
	//Fix U if certain singularvalue is below epsilon or equal to 0.
	if (S(0) < m_eps_singularvalue) //all singular values are equal to 0 or below epsilon
	{
		U = Eigen::Matrix3f::Identity();
	}
	else if (S(1) < m_eps_singularvalue) // two singular values are equal to 0 or below epsilon
	{
		Eigen::Vector3f v1 = U.col(0).unitOrthogonal();
		Eigen::Vector3f v2 = U.col(0).cross(v1).normalized();
		U.col(1) = v1;
		U.col(2) = v2;
	}
	else if (S(2) < m_eps_singularvalue) // one singular value is equal to 0 or below epsilon
	{
		U.col(2) = U.col(0).cross(U.col(1)).normalized();
	}

	//Fix U and negate minimal singularvalue if determinant of U is equal to -1
	if (U.determinant() < 0) // ==-1
	{
		U.col(2) = U.col(2) * (-1);
		S(2) *= -1;
	}
}
```

======================cubica

E:\mycode\collection\ANewCollection\elasticPlastic\stvkModeletc\cubica_INVERTIBLE.cpp

```
//////////////////////////////////////////////////////////////////////
// Print out various stats about F
//////////////////////////////////////////////////////////////////////
void INVERTIBLE::debugF(MATRIX3& F)
{
  cout << __FILE__ << " " << __FUNCTION__ << " " << __LINE__ << " : " << endl;
  cout << " P without filtering: " << _material->firstPiolaKirchhoff(F) << endl;
  cout << __FILE__ << " " << __FUNCTION__ << " " << __LINE__ << " : " << endl;

  // diagonalize F
  MATRIX3 U;
  MATRIX3 Fhat;
  MATRIX3 V;
  svd(F, U, Fhat, V);

  cout << " Decomposition: " << endl;
  cout << " U: " << U << endl;
  cout << " Fhat: " << Fhat << endl;
  cout << " V: " << V << endl;
 
  // filter Fhat
  for (int x = 0; x < 3; x++)
  {
    if (Fhat(x,x) < _epsilon)
    {
      Fhat(x,x) = _epsilon;
      x = 4;
    }
  }
  cout << " Fhat Filtered: " << Fhat << endl;
  
  MATRIX3 Phat = _material->firstPiolaKirchhoff(Fhat);

  // linearize past compression limit
  for (int x = 0; x < 3; x++)
  {
    if (Fhat(x,x) < 0.0)
      Phat(x,x) = _intercept + _slope * Fhat(x,x);
  }
  
  cout << " Phat Filtered: " << Phat << endl;
  cout << " Rotated P: " << U * Phat * V.transpose() << endl;
}

```

======================

eulers

E:\mycode\collection\ANewCollection\elasticPlastic\stvkModeletc\eulers_coratation.cpp

```
MATRIX3 COROTATION::firstPKDifferential(const MATRIX3& dF) {
  MATRIX3 dFhat = _R.transpose() * dF;
  MATRIX3 dFsym = 0.5 * (dFhat + dFhat.transpose());
  MATRIX3 dFskew = 0.5 * (dFhat - dFhat.transpose());

  MATRIX3 dPsym =
      (2 * _mu * dFsym) + (_lambda * trace(dFsym) * MATRIX3::Identity());

  VEC3F f(-dFskew(1, 2) + dFskew(2, 1), -dFskew(2, 0) + dFskew(0, 2),
          -dFskew(0, 1) + dFskew(1, 0));

  Real tr = _lambda * dFhat.trace();
  dPsym(0, 0) += tr;
  dPsym(1, 1) += tr;
  dPsym(2, 2) += tr;

  MATRIX3 dPskew = MATRIX_UTIL::cross(_L * f);
  MATRIX3 deltaP = dPsym + dPskew;
  return _R * deltaP;
  ;
}

```

===================deform

https://github.com/benjones/adaptiveDeformables/blob/master/DeformableObject.cpp

```
	//Eigen::JacobiSVD<Mat3> svd(F, Eigen::ComputeFullU | Eigen::ComputeFullV);
	Vec3 FHat = svd.S;//singularValues();
	Vec3 diagStress = lambda*(FHat(0) + FHat(1) + FHat(2) - 3)*Vec3(1,1,1) +
	  2*mu*(FHat - Vec3(1,1,1));
	
	Mat3 rotStress = svd.U.toRotationMatrix()*diagStress.asDiagonal()*(svd.V.toRotationMatrix().transpose());

	Mat3 forceCommon = dt*p.volume*rotStress*p.Ainv;
```

为什么不用极分解

![image-20211220211545205](E:\mycode\collection\新教程\image-20211220211545205.png)

为什么要不选QR分解

=====Invertible Finite Elements For Robust Simulation of Large  

![image-20211220211214970](E:\mycode\collection\新教程\image-20211220211214970.png)

# 

# 计算模态

神奇的bartels库

```
Here is an example of using Bartels to compute the first 20 deformation modes of a Neo-Hookean bunny:
 
    >> [V,T,F] = readMESH('/Users/dilevin/Documents/Research/Development/bartels/data/meshes_mesh/coarser_bunny.mesh');
    >> M = linear_tetmesh_mass_matrix(V,T, 0.1*ones(size(T,1),1), vol);
    >> YM = 2e6; %in Pascals
    >> pr =  0.45
    >> [lambda, mu] = emu_to_lame(YM*ones(size(T,1),1), pr*ones(size(T,1),1));
    >>  H = linear_tetmesh_neohookean_dq2(V,T, q, dX, vol, [0.5*mu, 0.5*lambda]);
    >> [modes, freq] = eigs(-H, M, 20, 'smallestabs');
    
 **NOTE:** I use [GPToolbox](https://github.com/alecjacobson/gptoolbox) by Alec Jacobson for file I/O (i.e readMESH) and geometry processing. 
```

# 并行计算技巧

这里收录了一些采用并行计算

pieletCloth

# 弹性模型调试技巧

首先是IGSim库中，会在单元测试，测试物体由未变形状态，伸长n%和缩短n%，所积蓄的能量是否一样，

```
double k = 1 + i * step;
F(0,0) = k;
sim::neohookean_model(F, mu, lambda, energy_test);

double k = 1.0 / i;
F(0,0) = k;
sim::neohookean_model(F, mu, lambda, energy_test);
```

# 看不懂，似乎很有用

```
    // compute A
    const Eigen::Matrix<double, dim, 1>& sigma = svd.singularValues();
    Eigen::Matrix<double, dim, 1> dE_div_dsigma;
    compute_dE_div_dsigma(sigma, u, lambda, dE_div_dsigma);
    Eigen::Matrix<double, dim, dim> d2E_div_dsigma2;
    compute_d2E_div_dsigma2(sigma, u, lambda, d2E_div_dsigma2);
    if (projectSPD) {
#if (DIM == 2)
        IglUtils::makePD2d(d2E_div_dsigma2);
#else
        IglUtils::makePD(d2E_div_dsigma2); //TODO: use implicit QR to accelerate
#endif
    }
```

# 碰撞

Efficient and Accurate Collision Response for Elastically Deformable Models  

![image-20211219134741926](E:\mycode\collection\新教程\image-20211219134741926.png)

![image-20211219134759465](E:\mycode\collection\新教程\image-20211219134759465.png)

# 问题

===========Stable Neo-Hookean Flesh Simulation  

While ΨD possesses inversion stability, it lacks what we will call rest
stability. In the solid mechanics literature (e.g. [Bonet and Wood
2008], §6.4.3) it is often mentioned that the hyperelastic energy
should vanish at identity.  



Hessian 矩阵相乘问题

```
Matrix2424 Cube::_ComputeForceJacobian(const Material& material, const std::vector<Vector3>& verts, const int gaussPoint) const
{
    const Matrix3 F = ComputeF(verts, gaussPoint);

    Matrix3 U;
    Matrix3 V;
    Vector3 S;
    RotationVariantSVD(F, U, V, S);

    return _pFpuMatrix[static_cast<unsigned long>(gaussPoint)].transpose() * (-_restVolume * material.ClampedPartialPpartialF(F, U, V, S)) * _pFpuMatrix[static_cast<unsigned long>(gaussPoint)];
}
```

# 校正体积

wangdme

```
		// Volume correction
		dEdIII	+=stiffness_1*(J-1)/J;
		H[2][2]	+=stiffness_1/(2*III*J);

		// Make H symmetric
		H[1][0]	= H[0][1];
		H[2][0]	= H[0][2];
		H[2][1]	= H[1][2];

		TYPE P0 = 2 * (dEdI*Sigma[0] + 2 * dEdII*Sigma[0] * Sigma[0] * Sigma[0] + dEdIII*III / Sigma[0]);
		TYPE P1 = 2 * (dEdI*Sigma[1] + 2 * dEdII*Sigma[1] * Sigma[1] * Sigma[1] + dEdIII*III / Sigma[1]);
		TYPE P2 = 2 * (dEdI*Sigma[2] + 2 * dEdII*Sigma[2] * Sigma[2] * Sigma[2] + dEdIII*III / Sigma[2]);
```

# 双B

E:\mycode\collection\ANewCollection\Energy\EnergyHessJacbian\zeno_stable_isotropic_NH.h

```
    void ComputePhiDerivHessian(const Mat3x3d& activation,
            const Vec3d& aniso_weight,const Mat3x3d& fiber_direction,const FEM_Scaler& YoungModulus,const FEM_Scaler& PossonRatio,
            const Mat3x3d &F,FEM_Scaler& energy,Vec9d &derivative, Mat9x9d &Hessian,bool enforcing_spd = true) const override {

        Mat3x3d ActInv = activation.inverse();
        Mat3x3d FAct = F * ActInv;

        FEM_Scaler mu = Enu2Mu(YoungModulus,PossonRatio);
        FEM_Scaler lambda = Enu2Lambda(YoungModulus,PossonRatio);

        Vec3d Is;
        std::array<Vec9d,3> gs;
        EvalIsoInvarientsDeriv(FAct,Is,gs);

        eval_phi(lambda,mu,Is,energy);

        Vec3d dphi;
        eval_dphi(lambda,mu,Is,dphi);


        Mat9x9d dFactdF = EvaldFactdF(ActInv); 

        derivative = dphi[0] * gs[0] + dphi[1] * gs[1] + dphi[2] * gs[2];     
        derivative = dFactdF.transpose() * derivative;

        Vec9d eigen_vecs[9];
        Vec9d eigen_vals;
            
        // compute the eigen system of Hessian
        ComputeIsoEigenSystem(YoungModulus,PossonRatio, FAct, eigen_vals, eigen_vecs);  
        if (enforcing_spd) {
            for (size_t i = 0; i < 9; ++i)
                eigen_vals[i] = eigen_vals[i] > 1e-12 ? eigen_vals[i] : 1e-12;
        }
        Hessian.setZero();
        for(size_t i = 0;i < 9;++i){
            Hessian += eigen_vals[i] * eigen_vecs[i] * eigen_vecs[i].transpose();
        }

        Hessian = dFactdF.transpose() * Hessian * dFactdF; 
    }
```

D:\图形学书籍\论文\Descent Methods for Elastic Body Simulation on the GPU.pdf

![image-20211220205708860](E:\mycode\collection\新教程\image-20211220205708860.png)
