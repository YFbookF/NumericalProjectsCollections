

The method of Lagrange multiplier is a convenient way to solve problems subject to some given constraints. As an example, consider the problem of obtaining stationary value of some function
$$
df = \frac{\partial f}{\partial x_1}dx_1 + \frac{\partial f}{\partial x_2}dx_2 + ... + \frac{\partial f}{\partial x_n}dx_n = 0
$$
如果限制如下
$$
c_1(x) = 0 \qquad c_2(x) = 0
$$
那么接下来
$$
f^* = f+ \sum_i \lambda_i c_i = f + \lambda_1 c_1 + \lambda_2 c_2
$$
接下来对f* 微分
$$
\frac{\partial f}{\partial x_i} + \lambda_1 \frac{\partial c_1}{\partial x_1} + \lambda_2 \frac{\partial c_2}{\partial x_i} = 0
$$
The following relations
$$
\sum_{i=1}^n \frac{\partial c_1}{\partial x_i}dx = 0 = \sum_{i=1}^n\frac{\partial c_2}{\partial x_2}dx_i
$$
接下来
$$
\sum_{i=1}^n(\frac{\partial f}{\partial x_2} + \lambda\frac{\partial c_1}{\partial x_i} + \\frac{\partial c_2}{\partial x_i})dx_i
$$
Position-Based Simulation of Continuous Materials  

https://github.com/InteractiveComputerGraphics/PositionBasedDynamics/blob/master/PositionBasedDynamics/PositionBasedFluids.cpp

```
const Real C = std::max(density / density0 - static_cast<Real>(1.0), static_cast<Real>(0.0));			// clamp to prevent particle clumping at surface

	if (C != 0.0)
	{
		// Compute gradients dC/dx_j 
		Real sum_grad_C2 = 0.0;
		Vector3r gradC_i(0.0, 0.0, 0.0);

		for (unsigned int j = 0; j < numNeighbors; j++)
		{
			const unsigned int neighborIndex = neighbors[j];
			if (neighborIndex < numberOfParticles)		// Test if fluid particle
			{
				const Vector3r gradC_j = -mass[neighborIndex] / density0 * CubicKernel::gradW(x[particleIndex] - x[neighborIndex]);
				sum_grad_C2 += gradC_j.squaredNorm();
				gradC_i -= gradC_j;
			}
			else if (boundaryHandling)
			{
				// Boundary: Akinci2012
				const Vector3r gradC_j = -boundaryPsi[neighborIndex - numberOfParticles] / density0 * CubicKernel::gradW(x[particleIndex] - boundaryX[neighborIndex - numberOfParticles]);
				sum_grad_C2 += gradC_j.squaredNorm();
				gradC_i -= gradC_j;
			}
		}

		sum_grad_C2 += gradC_i.squaredNorm();

		// Compute lambda
		lambda = -C / (sum_grad_C2 + eps);
	}
```

![image-20211029135355299](D:\定理\数学\image-20211029135355299.png)

===============Direct Position-Based Solver for Stiff Rods  
$$
\bold M \ddot {\bold x} = -\nabla U(x) + \bold f_{ext}
$$
差分
$$
\bold M(\frac{\bold x(t+\Delta t) - 2\bold x(t) + \bold x(t - \Delta t)}{\Delta t^2}) = -\nabla U(\bold x(t + \Delta t)) + \bold f_{ext}
$$
elastic potential Ux has the form
$$
U(\bold x) = \frac{1}{2}\bold C(\bold x)^T\vec \alpha^{-1}\bold C(\bold x)
$$
C x is a vector of constraint function, alpha is the diagonal compliance matrix describing the inverse stiffness. 比如对于Cosserat 的bending 和Torsion来说，C就是dOmega，alpha就是K-1

看看
$$
E_b = \frac{1}{2}\int \Delta \Omega^T K\Delta \Omega ds \qquad K = \begin{bmatrix} EI_1 & 0 & 0 \\ 0 & EI_2 & 0 \\ 0 & 0 & GJ\end{bmatrix}
$$
算力的时候
$$
\bold f_{el} = -\nabla U(\bold x) = -\bold J^T \vec \alpha ^{-1} \bold C = \Delta t^2 \bold J^T \vec \lambda \qquad \bold J = \nabla \bold C
$$
lambda 就是 Lagrane multiplier

![image-20211030131740751](D:\定理\数学\image-20211030131740751.png)

===========Finite Element Modeling For Stress Aanlysis

section 4.13

The Lagrange multiplier method, which imposes constraints exactly, and the penalty method, which imposes contraints approximately

An equation of constraint has the general form
$$
\bold C \bold D - \bold Q = \bold 0
$$
C is an m by n matrix, m is the number of constraint equations, n is the number of dof in global vector D. Q is vector of constraints.

which produces the modified total energy expression
$$
\Pi = \frac{1}{2}\bold D^T \bold K \bold D - \bold D^T \bold R + \lambda^T (\bold C\bold D - \bold Q)
$$
让Pi对D求导，变成了下面这样的方程
$$
\begin{bmatrix}\bold K & \bold C^T \\ \bold C & \bold 0 \end{bmatrix}\begin{bmatrix}\bold D \\ \lambda \end{bmatrix} = \begin{bmatrix}\bold R \\ \bold Q \end{bmatrix}
$$
![image-20211102152728345](D:\定理\数学\image-20211102152728345.png)

这样我们可以换成拉格朗日乘子法
$$
\begin{bmatrix} k & -k & 1 \\ -k & 2k & -1 \\ 1 & -1 & 0\end{bmatrix}\begin{bmatrix}u_1\\ u_2 \\ \lambda\end{bmatrix} = \begin{bmatrix} P \\ 0 \\ 0\end{bmatrix}
$$
解为
$$
u_1 = u_2 = \frac{P}{k} \qquad \lambda = P
$$


