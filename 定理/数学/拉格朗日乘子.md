

The method of Lagrange multiplier is a convenient way to solve problems subject to some given constraints. As an example, consider the problem of obtaining stationary value of some function
$$
df = \frac{\partial f}{\partial x_1}dx_1 + \frac{\partial f}{\partial x_2}dx_2 + ... + \frac{\partial f}{\partial x_n}dx_n = 0
$$
如果限制如下
$$
c_1(x) = 0 \qquad c_2(x) = 0
$$
那么接下来
$$
f^* = f+ \sum_i \lambda_i c_i = f + \lambda_1 c_1 + \lambda_2 c_2
$$
接下来对f* 微分
$$
\frac{\partial f}{\partial x_i} + \lambda_1 \frac{\partial c_1}{\partial x_1} + \lambda_2 \frac{\partial c_2}{\partial x_i} = 0
$$
The following relations
$$
\sum_{i=1}^n \frac{\partial c_1}{\partial x_i}dx = 0 = \sum_{i=1}^n\frac{\partial c_2}{\partial x_2}dx_i
$$
接下来
$$
\sum_{i=1}^n(\frac{\partial f}{\partial x_2} + \lambda\frac{\partial c_1}{\partial x_i} + \\frac{\partial c_2}{\partial x_i})dx_i
$$
Position-Based Simulation of Continuous Materials  

https://github.com/InteractiveComputerGraphics/PositionBasedDynamics/blob/master/PositionBasedDynamics/PositionBasedFluids.cpp

```
const Real C = std::max(density / density0 - static_cast<Real>(1.0), static_cast<Real>(0.0));			// clamp to prevent particle clumping at surface

	if (C != 0.0)
	{
		// Compute gradients dC/dx_j 
		Real sum_grad_C2 = 0.0;
		Vector3r gradC_i(0.0, 0.0, 0.0);

		for (unsigned int j = 0; j < numNeighbors; j++)
		{
			const unsigned int neighborIndex = neighbors[j];
			if (neighborIndex < numberOfParticles)		// Test if fluid particle
			{
				const Vector3r gradC_j = -mass[neighborIndex] / density0 * CubicKernel::gradW(x[particleIndex] - x[neighborIndex]);
				sum_grad_C2 += gradC_j.squaredNorm();
				gradC_i -= gradC_j;
			}
			else if (boundaryHandling)
			{
				// Boundary: Akinci2012
				const Vector3r gradC_j = -boundaryPsi[neighborIndex - numberOfParticles] / density0 * CubicKernel::gradW(x[particleIndex] - boundaryX[neighborIndex - numberOfParticles]);
				sum_grad_C2 += gradC_j.squaredNorm();
				gradC_i -= gradC_j;
			}
		}

		sum_grad_C2 += gradC_i.squaredNorm();

		// Compute lambda
		lambda = -C / (sum_grad_C2 + eps);
	}
```

![image-20211029135355299](E:\mycode\collection\定理\数学\image-20211029135355299.png)

===============Direct Position-Based Solver for Stiff Rods  
$$
\bold M \ddot {\bold x} = -\nabla U(x) + \bold f_{ext}
$$
差分
$$
\bold M(\frac{\bold x(t+\Delta t) - 2\bold x(t) + \bold x(t - \Delta t)}{\Delta t^2}) = -\nabla U(\bold x(t + \Delta t)) + \bold f_{ext}
$$
elastic potential Ux has the form
$$
U(\bold x) = \frac{1}{2}\bold C(\bold x)^T\vec \alpha^{-1}\bold C(\bold x)
$$
C x is a vector of constraint function, alpha is the diagonal compliance matrix describing the inverse stiffness. 比如对于Cosserat 的bending 和Torsion来说，C就是dOmega，alpha就是K-1

看看
$$
E_b = \frac{1}{2}\int \Delta \Omega^T K\Delta \Omega ds \qquad K = \begin{bmatrix} EI_1 & 0 & 0 \\ 0 & EI_2 & 0 \\ 0 & 0 & GJ\end{bmatrix}
$$
算力的时候
$$
\bold f_{el} = -\nabla U(\bold x) = -\bold J^T \vec \alpha ^{-1} \bold C = \Delta t^2 \bold J^T \vec \lambda \qquad \bold J = \nabla \bold C
$$
lambda 就是 Lagrane multiplier

![image-20211030131740751](E:\mycode\collection\定理\数学\image-20211030131740751.png)

===========Finite Element Modeling For Stress Aanlysis

section 4.13

The Lagrange multiplier method, which imposes constraints exactly, and the penalty method, which imposes contraints approximately

An equation of constraint has the general form
$$
\bold C \bold D - \bold Q = \bold 0
$$
C is an m by n matrix, m is the number of constraint equations, n is the number of dof in global vector D. Q is vector of constraints.

which produces the modified total energy expression
$$
\Pi = \frac{1}{2}\bold D^T \bold K \bold D - \bold D^T \bold R + \lambda^T (\bold C\bold D - \bold Q)
$$
让Pi对D求导，变成了下面这样的方程
$$
\begin{bmatrix}\bold K & \bold C^T \\ \bold C & \bold 0 \end{bmatrix}\begin{bmatrix}\bold D \\ \lambda \end{bmatrix} = \begin{bmatrix}\bold R \\ \bold Q \end{bmatrix}
$$
![image-20211102152728345](E:\mycode\collection\定理\数学\image-20211102152728345.png)

这样我们可以换成拉格朗日乘子法
$$
\begin{bmatrix} k & -k & 1 \\ -k & 2k & -1 \\ 1 & -1 & 0\end{bmatrix}\begin{bmatrix}u_1\\ u_2 \\ \lambda\end{bmatrix} = \begin{bmatrix} P \\ 0 \\ 0\end{bmatrix}
$$
解为
$$
u_1 = u_2 = \frac{P}{k} \qquad \lambda = P
$$

====================An introduction to physics based animation

约束可以是物理的，让粒子遵循物理法则，也可以是几何，让粒子仅在某个平面上运动。

consider the constraint equation
$$
g(\bold x) = 0
$$
where bold x = (x1,x2,x3...xn) This is an implicit surface equation defining all the legal position x the gradient of the constraint is the vector
$$
\nabla g(\bold x) = \begin{bmatrix} \partial g/\partial x_1(\bold x) \\  \partial g/\partial x_2(\bold x)\\ \partial g/\partial x_3(\bold x)\\ \partial g/\partial x_4(\bold x)\\..\end{bmatrix}
$$
同时我们考虑Constraint Force，它做的一定是虚功。如果F 要想把粒子弄离约束屏幕，那么就会产生一个约束力，这里的例外的摩擦力。接下来的约束力我们假设都和dg(x)的方向一样，因此做功都是零



![image-20211113165844326](E:\mycode\collection\定理\数学\image-20211113165844326.png)
$$
\bold F_C^T \delta \bold r = 0 \qquad \bold F_c = \lambda \nabla g
$$
![image-20211113170025433](E:\mycode\collection\定理\数学\image-20211113170025433.png)

F 是那个圆，不断扩大。g是那个双曲线。

In this case, the total constraint forces is comprised of m terms, one each for constraint,
$$
\lambda_1 \nabla g_1 + \lambda_2 \nabla g_2 + \lambda_3 \nabla g_3
$$
which we write
$$
\bold F_c = J^T \vec \lambda \qquad M\bold a = \bold F+ \bold F_c = \bold F + \lambda J^T
$$
![image-20211113170332393](E:\mycode\collection\定理\数学\image-20211113170332393.png)

x 是 maximal coordinate，就是正常的笛卡尔坐标系，q 是generalized coordinate，就是被限制住自由度的坐标系。比如摆锤



![image-20211113171701862](E:\mycode\collection\定理\数学\image-20211113171701862.png)
$$
\dot{\bold x} = \begin{bmatrix}\dot{x}(\theta) \\ \dot{y}(\theta) \end{bmatrix}=\begin{bmatrix} l\cos \theta \dot{\theta} \\ l \sin \theta \dot{\theta} \end{bmatrix} = J \dot{\theta}
$$
Lagrange equation of motion，其实上面这样的
$$
G = J^T\bold F = \begin{bmatrix}I \\ \bold r^* \end{bmatrix}\bold F = \begin{bmatrix} \bold F \\ \bold r \times \bold F \end{bmatrix} = \frac{d}{dt}(\frac{\partial T}{\partial \bold {\dot q}}) 
$$
再来推导一遍从笛卡尔坐标系到圆坐标系的
$$
\dot{\bold x} = \begin{bmatrix}I & \bold r^{*T} \end{bmatrix}\begin{bmatrix}\bold v \\ \bold w \end{bmatrix} \qquad J = \begin{bmatrix}I & \bold r^{*T} \end{bmatrix}
$$
我们可以算T，进而算上面式子最右边的偏微分
$$
T = \frac{1}{2}m(\dot{x}^2 + \dot{y}^2) = \frac{1}{2}ml^2\dot{\theta}^2 \qquad \frac{d}{dt}(\frac{\partial T}{\partial \dot \theta}) = ml^2 \ddot \theta
$$
记住F 是笛卡尔坐标系，也就是
$$
G = J^T \begin{bmatrix}0 \\ -mg \end{bmatrix} = J^T \begin{bmatrix}l\cos \theta & l\sin \theta \end{bmatrix} \begin{bmatrix}0 \\ -mg \end{bmatrix} = -lmg\sin\theta
$$
最后

https://www.gamedev.net/tutorials/programming/math-and-physics/understanding-constraint-resolution-in-physics-engine-r4839/

=======================RedMax

![image-20211114215934920](E:\mycode\collection\定理\数学\image-20211114215934920.png)
