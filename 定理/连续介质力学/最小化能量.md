

as rigid as possible

物体变形后前，可以用R矩阵表示向量的旋转
$$
\bold p'_i - \bold p_j' = \bold R_i(\bold p_i - \bold p_j)
$$
能量可以用加权最小二乘法
$$
E = \sum_jw_{ij}||(\bold p_i' - \bold p_j') - \bold R_i(\bold p_i - \bold p_j)||^2
$$
![image-20211102112038852](D:\定理\连续介质力学\image-20211102112038852.png)

其中的wij可以
$$
w_{ij} = \frac{1}{2}(\cot \alpha_{ij} + \cot \beta_{ij})
$$
alpha和beta是两个三角形关于共同边的的对角。

https://github.com/fanxiaochen/ARAP/blob/master/src/Deform.cpp

```
float Deform::compute_wij(const float *p1, const float *p2, const float *p3, const float *p4)
{
    float e1 = sqrt((p1[0]-p2[0])*(p1[0]-p2[0])+(p1[1]-p2[1])*(p1[1]-p2[1])+(p1[2]-p2[2])*(p1[2]-p2[2]));
    float e2 = sqrt((p1[0]-p3[0])*(p1[0]-p3[0])+(p1[1]-p3[1])*(p1[1]-p3[1])+(p1[2]-p3[2])*(p1[2]-p3[2]));
    float e3 = sqrt((p3[0]-p2[0])*(p3[0]-p2[0])+(p3[1]-p2[1])*(p3[1]-p2[1])+(p3[2]-p2[2])*(p3[2]-p2[2]));
    float alpha_cos = fabs((e3*e3+e2*e2-e1*e1)/(2*e3*e2));
    float beta_cos = 0;
    if (p4 != nullptr) {
        float e4 = sqrt((p1[0]-p4[0])*(p1[0]-p4[0])+(p1[1]-p4[1])*(p1[1]-p4[1])+(p1[2]-p4[2])*(p1[2]-p4[2]));
        float e5 = sqrt((p4[0]-p2[0])*(p4[0]-p2[0])+(p4[1]-p2[1])*(p4[1]-p2[1])+(p4[2]-p2[2])*(p4[2]-p2[2]));
        beta_cos = fabs((e4*e4+e5*e5-e1*e1)/(2*e4*e5));
    }
    return ((alpha_cos/sqrt(1-alpha_cos*alpha_cos))+(beta_cos/sqrt(1-beta_cos*beta_cos)))/2;
}
```

![image-20211102112229017](D:\定理\连续介质力学\image-20211102112229017.png)

```
void Deform::update_Ri()
{
    Matrix3f Si;
    MatrixXf Di;
    Matrix3Xf Pi_Prime;
    Matrix3Xf Pi;
    for (int i = 0; i != P_Num; ++i) {
        Di = MatrixXf::Zero(adj_list[i].size(), adj_list[i].size());
        Pi_Prime.resize(3, adj_list[i].size());
        Pi.resize(3, adj_list[i].size());
        // if there is not any single unconnected point this for loop can have a more efficient representation
        for (decltype(adj_list[i].size()) j = 0; j != adj_list[i].size(); ++j) {
            Di(j, j) = Weight.coeffRef(i, adj_list[i][j]);
            Pi.col(j) = P.col(i) - P.col(adj_list[i][j]);
            Pi_Prime.col(j) = P_Prime.col(i) - P_Prime.col(adj_list[i][j]);
        }
        Si = Pi * Di * Pi_Prime.transpose();
        Matrix3f Ui;
        Vector3f Wi;
        Matrix3f Vi;
        wunderSVD3x3(Si, Ui, Wi, Vi);
        R[i] = Vi * Ui.transpose();

        if (R[i].determinant() < 0)
            std::cout << "determinant is negative!" << std::endl;
    }
}
```

或者

```
//https://github.com/TanaTanoi/as-rigid-as-possible-deformation/blob/master/arap.py
def calculate_covariance_matrix_for_cell(self, vert_id):
        # s_i = P_i * D_i * P_i_prime_transpose
        vert_i_prime = self.verts_prime[vert_id]

        neighbour_ids = self.neighbours_of(vert_id)
        number_of_neighbours = len(neighbour_ids)

        D_i = np.zeros((number_of_neighbours, number_of_neighbours))

        P_i =       self.P_i_array[vert_id]
        P_i_prime = np.zeros((3, number_of_neighbours))

        for n_i in range(number_of_neighbours):
            n_id = neighbour_ids[n_i]

            D_i[n_i, n_i] = self.weight_matrix[vert_id, n_id]

            vert_j_prime = self.verts_prime[n_id]
            P_i_prime[:, n_i] = (vert_i_prime - vert_j_prime)

        P_i_prime = P_i_prime.transpose()
        return P_i.dot(D_i).dot(P_i_prime)
```

等式右边

```
//https://github.com/TanaTanoi/as-rigid-as-possible-deformation/blob/master/arap.py
def calculate_b_for(self, i):
        b = np.zeros((1, 3))
        neighbours = self.neighbours_of(i)
        for j in neighbours:
            w_ij = self.weight_matrix[i, j] / 2.0
            r_ij = self.cell_rotations[i] + self.cell_rotations[j]
            # print(r_ij)
            p_ij = self.verts[i] - self.verts[j]
            b += (w_ij * r_ij.dot(p_ij))
        return b
```

等式左边

```
    def calculate_laplacian_matrix(self):
        # initial laplacian
        # self.laplacian_matrix = self.edge_matrix - self.neighbour_matrix
        self.laplacian_matrix = self.weight_sum - self.weight_matrix
        fixed_verts_num = len(self.fixed_verts)
        # for each constrained point, add a new row and col
        new_n = self.n + fixed_verts_num
        new_matrix = matrix((new_n, new_n), dtype=np.float)
        # Assign old values to new matrix
        new_matrix[:self.n, :self.n] = self.laplacian_matrix
        # Add 1s in the row and column associated with the fixed point to constain it
        # This will increase L by the size of fixed_verts
        for i in range(fixed_verts_num):
            new_i = self.n + i
            vert_id = self.fixed_verts[i][0]
            new_matrix[new_i, vert_id] = 1
            new_matrix[vert_id, new_i] = 1
        print(self.laplacian_matrix)
```

