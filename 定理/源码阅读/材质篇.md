有关光线追踪光照的概念介绍，各种文章，博客，书籍已经介绍得很不错了，比如“Physically Based Rendering From Theory to Implementation“。但是这些文章很多仅仅是给出一堆公式和图，有的不错的教程倒会给出代码，但也仅仅是自己的实现方向。如果想要博采众家之长，显然是不够的，因此我收集了一些开源渲染器中一些函数的实现方向，通过横向比较来发现它们的特点。

还有个问题，自学非常容易跑偏方向。所以非常需要这些开源渲染器的源码作为参考，避免自己犯一些低级错误。虽然这些源码我现在并不能完全看懂，但仍然记录下给自己留下印象，以便今后看到公式时能够想起来自己曾经收集了源码。

# 材质篇简介

本篇文章大约收录了11个库的有关材质的70份源码，

不仅有收录了基础材质的源码，还包括一些特殊材质如头发，布料，多层材质。即使是相同的材质，不同的库也有不同的实现方法。这些材质大多数是用在光线追踪中，但也可用于光栅化渲染器中。如果用于光线追踪的话，均在每个材质类中实现了三种函数。

第一种是采样函数，给出出射光线的方向，给出材质，返回入射光线的方向。

第二种是eval函数，也就是用于计算bsdf的值，这个值可以理解为某个特定的入射光线打到表面后，还剩下多少强度留给某个特定的出射光线。

第三种是概率密度函数，也就是pdf。主要用于算蒙特卡洛积分。

这些代码看多了，就会发现，某些地方与各书籍与论文上说得并不一样。

# 基础材质

## 漫反射

又名为Diffuse或Lambertain，为粗糙表面常见的光线反射方式。

### appleseed库

appleseed是一个开源渲染引擎的名称，简介请拉到最下面。在appleseed库的diffusebtdf.cpp，入射光线为半球cos采样，bsdf的值为物体本身的透射率除以PI，而pdf为入射光线的z轴除以PI。

```
wi = sample_hemisphere_cosine(s);
f = m_transmittance *m_multiplier /	M_PI;
pdf = wi.y / PI;
```

为什么是入射光线的z轴呢？在看到这些源码之前我永远想不到，主流开源渲染器用在采样光线时，一般都是使用本地坐标，所以入射光线的z轴，其实和世界坐标下入射光线和法向量的点积是一个意思。

### tungsten库

tungsten库的LambertBsdf.cpp与之前这个库的实现方式略有区别，首先它管透射率叫做albedo，在计算bsdf的时候还会检验光线的合法性，如果入射光线和出射光线不在同一个半球，那么说明入射光线不合法，bsdf直接设为零。并且，albedo似乎是存储在纹理上的，物体上每一点的albeo都不同。

```
event.wo  = SampleWarp::cosineHemisphere(event.sampler->next2D());
f = albedo(event.info)*INV_PI*event.wo.z();
if (!event.requestedLobe.test(BsdfLobes::DiffuseReflectionLobe))
        f = Vec3f(0.0f);
if (event.wi.z() <= 0.0f || event.wo.z() <= 0.0f)
        f = Vec3f(0.0f);
event.pdf = SampleWarp::cosineHemispherePdf(event.wo);
```

大部分开源渲染器在材质类中，都会非常注意检验光线的合法性，函数调用，进入函数后的第一件事就是检验光线是否合法，不合法立即返回零。对于漫反射来说，只要入射光线和出射光线在同一个半球才合法。

### mitsuba库

在diffuse.cpp中，这里的实现方式和appleseed是一样的。

```
wi = squareToCosineHemisphere();
f = m_reflectance->evalAtPoint(bRec.its) * (INV_PI * Frame::cosTheta(bRec.wo));
squareToCosineHemispherePdf = INV_PI * Frame::cosTheta(wi);
```

还有很多库也实现了漫反射材质，由于很简单这里就不一一介绍了。

## 高光反射

又称specular 或 mirror。反射光线集中在很小的区域。

### luxcore库

在mirror.cpp中是很简单的镜面反射，计算时使用了本地坐标。bsdf的值直接使用预先设定好的值。概率密度函数为1。

```
*localSampledDir = Vector(-localFixedDir.x, -localFixedDir.y, localFixedDir.z);
fr =  Kr->GetSpectrumValue(hitPoint).Clamp(0.f, 1.f);
*pdfW = 1.f;
```

### tungsten库

在MirrorBsdf.cpp中直接使用albedo值作为bsdf值。

```
event.wo = Vec3f(-event.wi.x(), -event.wi.y(), event.wi.z());
fr = albedo(event.info);
event.pdf = 1.0f;
```

### yocto库

在yocto_shading.h中的sample_reflective()，有使用微表面模型和不使用的两种版本。

不使用微表面模型的版本中，反射使用世界坐标的反射。而bsdf的值直接使用了导体Fresnel的值。概率密度函数仍然为1。

```
auto up_normal = dot(normal, outgoing) <= 0 ? -normal : normal;
incoming = reflect(outgoing, up_normal);
f = fresnel_conductor(eta, etak, up_normal, outgoing);
pdf = 1;
```

微表面模型，所以在采样函数中需要使用微表面模型计算中间向量，这种微表面模型与learnopengl上介绍的差不多。

```
auto up_normal = dot(normal, outgoing) <= 0 ? -normal : normal;
auto halfway   = sample_microfacet(roughness, up_normal, rn);
incoming = reflect(outgoing, halfway);

auto F         = fresnel_conductor(eta, etak, halfway, incoming);
auto D         = microfacet_distribution(roughness, up_normal, halfway);
auto G         = microfacet_shadowing(roughness, up_normal, halfway, outgoing);
f = F * D * G / (4 * dot(up_normal, outgoing) * dot(up_normal, incoming)) *
         			abs(dot(up_normal, incoming));
         			
pdf =  sample_microfacet_pdf(roughness, up_normal, halfway) 
         /(4 * abs(dot(outgoing, halfway)));
```

## DiffuseTransmission

这种特殊的材质假设光线击中物体表面后，会透射过去并在相反的表面进行漫反射。

### mitsuba库

在diffusetran.cpp，仅认为光线会全部透射过去并在相反的表面进行漫反射。

sample函数中对于这个写得很清楚。这里用的是本地坐标，算起来很方便。

```
bRec.wo = warp::squareToCosineHemisphere(sample);
if (Frame::cosTheta(bRec.wi) > 0)bRec.wo.z *= -1;
```

evaluate函数与普通的漫反射没什么不同，仅仅是判断光线存在性时，如果入射光线与出射光线点积大于零，那么这次折射就不可能发生。

```
if (!(bRec.typeMask & EDiffuseTransmission) || measure != ESolidAngle
            || Frame::cosTheta(bRec.wi) * Frame::cosTheta(bRec.wo) >= 0)
            return Spectrum(0.0f);
return m_transmittance->eval(bRec.its)
            * (INV_PI * std::abs(Frame::cosTheta(bRec.wo)));
```

pdf函数也是与普通漫反射一样

```
return std::abs(Frame::cosTheta(bRec.wo)) * INV_PI;
```

### tungsten库

在DiffuseTransmissionBsdf.cpp，认为光线可能会透射，也可能不会。但之后都会发生漫反射。

sample函数

```
event.wo = SampleWarp::cosineHemisphere(event.sampler->next2D());
event.wo.z() = std::copysign(event.wo.z(), event.wi.z());
if (transmit)event.wo.z() = -event.wo.z();
```

evaluate函数，在光线没有透射的时候，为了能量守恒，因子是1 - T。

```
float factor = event.wi.z()*event.wo.z() < 0.0f ? _transmittance : 1.0f - _transmittance;
return albedo(event.info)*factor*INV_PI*std::abs(event.wo.z());
```

pdf函数，同样在光线没透射的时候，要遵循能力守恒原则。

```
float factor = event.wi.z()*event.wo.z() < 0.0f ? transmittanceProbability : 1.0f - transmittanceProbability;
return factor*SampleWarp::cosineHemispherePdf(event.wo);
```

### yocto库

在yocto_shading.h中，采样函数就是简单的cos半球采样

```
auto up_normal = dot(normal, outgoing) <= 0 ? -normal : normal;
return sample_hemisphere_cos(-up_normal, rn);
//注意与下面的标准漫反射采样对比，半透明材质用的是反的法向量
//sample_hemisphere_cos(up_normal, rn);
```

evaluate采样

```
if (dot(normal, incoming) * dot(normal, outgoing) >= 0) return {0, 0, 0};
//注意与下面的标准漫反射合法性检测对比
//if (dot(normal, incoming) * dot(normal, outgoing) <= 0) return {0, 0, 0};
return color / pif * abs(dot(normal, incoming));
```

概率密度函数

```
if (dot(normal, incoming) * dot(normal, outgoing) >= 0) return 0;
auto up_normal = dot(normal, outgoing) <= 0 ? -normal : normal;
return sample_hemisphere_cos_pdf(-up_normal, incoming);
```

### pbrt-v3库

在reflection.cpp中，采样函数如下

```
    *wi = CosineSampleHemisphere(u);
    if (wo.z > 0) wi->z *= -1;
```

evaluate函数如下，T是透射率

```
return T * InvPi;
```

pdf函数如下

```
return R * InvPi;
```

## 导体

导体其实高光反射差不多。导体与电解质相反，导体不透射任何光线。

### mitsuba

在conductor,cpp中，sample函数中入射光线为标准镜面反射。

evaluate函数中，只返回一种可能值，即物体表面被击中点的高光反射率，乘上Fresnel导体系数。没有透射或折射影响。值得注意的是，之前在高光反射时，bsdf值不是高光反射率就是Fresnel函数，但在导体中，却将它们两种乘在了一起。

```
return m_specularReflectance->eval(bRec.its) *
            fresnelConductorExact(Frame::cosTheta(bRec.wi), m_eta, m_k);
```

pdf函数中，判断以一光线是否不太离谱，然后返回0或1。

```
if (!sampleReflection || measure != EDiscrete ||Frame::cosTheta(bRec.wi) <= 0 ||
Frame::cosTheta(bRec.wo) <= 0 ||std::abs(dot(reflect(bRec.wi), bRec.wo)-1) > DeltaEpsilon)
       return 0.0f;
return 1.0f;
```

### tungsten库

在ConductorBsdf.cpp中，采样函数仍然用本地坐标

```
event.wo = Vec3f(-event.wi.x(), -event.wi.y(), event.wi.z());
```

evaluate函数中，用的是材质的albedo乘上菲涅尔导体系数

```
event.weight = albedo(event.info)*Fresnel::conductorReflectance(_eta, _k, event.wi.z());
```

pdf函数中返回1。

## 粗糙导体

### tungsten库

在RoughConductorBsdf.cpp中，使用了微表面模型。

控制参数包括

roughness，用于计算微表面模型上的法向量。

eta，用于计算导体Fresnel反射

k，用于导体Fresnel反射

采样函数只有镜面反射。evaluate函数如下

```
Vec3f F = Fresnel::conductorReflectance(_eta, _k, cosThetaM);
float G = Microfacet::G(_distribution, alpha, event.wi, event.wo, hr);
float D = Microfacet::D(_distribution, alpha, hr);
float fr = (G*D*0.25f)/event.wi.z();
return albedo(event.info)*(F*fr);
```

pdf函数如下

```
float mPdf = Microfacet::pdf(_distribution, sampleAlpha, m);
float pdf = mPdf*0.25f/wiDotM;
```

### mitsuba库

在roughtconductor.cpp中，参考论文为Microfacet Modelsor Refraction through Rough Surfaces'' by Walter et al。总体与tungsten库一样。

## 金属

又称为metal。光线在其上方只会发生镜面反射。

### luxcore库

代码在metal2.cpp中。对于金属材质，luxcore用的是微表面模型。入射光线为镜面反射，不过反射时需要用的的中间向量h来源于shclick模型。

```
SchlickDistribution_SampleH(roughness, anisotropy, u0, u1, &wh, &d, &specPdf);
const float cosWH = Dot(localFixedDir, wh);
*localSampledDir = 2.f * cosWH * wh - localFixedDir;
```

计算bsdf的时候，也涉及到了微表面模型。

```
float factor = (d / specPdf) * G * fabsf(cosWH);
if (!hitPoint.fromLight) factor /= coso;
else factor /= cosi;
fr =  factor * F;
```

然后算概率密度的时候，主要由三个参数控制，分别是粗糙度roughness，中间向量wh，以及各项异性度anisotropy

```
cosTheta = fabsf(wh.z);
const float h = sqrtf(wh.x* wh.x+ wh.y * wh.y);
SchlickA = 1;
if (h > 0.f) {
		const float w = (anisotropy > 0.f ? H.x : H.y) / h;
		const float p = 1.f - fabsf(anisotropy);
		SchlickA = sqrtf(p / (p * p + w * w * (1.f - p * p)));
}
SchlickZ = 0
if (roughness > 0.f) {
		const float cosNH2 = cosTheta * cosTheta;
		// expanded for increased numerical stability
		const float d = cosNH2 * roughness + (1.f - cosNH2);
		// use double division to avoid overflow in d*d product
		SchlickZ =  (roughness / d) / d;
}
pdf = SchlickZ * SchlickA;
```

### appleseed库

在metalbrdf.cpp中，参考论文如下

```
//   [1] Microfacet Models for Refraction through Rough Surfaces
//       http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf
//   [2] Revisiting Physically Based Shading at Imageworks
//       http://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_slides.pdf
//   [3] Practical multiple scattering compensation for microfacet models
//       https://blog.selfshadow.com/publications/turquin/ms_comp_final.pdf
```

采样时，先判断粗糙度是不是非常小，如果是，就按之前的镜面反射来处理，如果不是，就按微表面模型来处里。

```
MicrofacetBRDFHelper<GGXMDF>::sample();
//apply_energy_compensation_factor();
const float Ess = get_directional_albedo();
Spectrum fms = values->m_normal_reflectance;
fms *= values->m_energy_compensation * (1.0f - Ess) / Ess;
fms += Spectrum(1.0f);
bsdf *= fms;
pdf = MicrofacetBRDFHelper<GGXMDF>::pdf();
```



## OrenNayar

这个材质可以称为更真实的漫反射。在pbrt第三版的介绍为，采样时由一个参数sigma控制粗糙度，足够光滑则均匀半球采样，否则cos半球采样，但实际上并没有几个开源渲染库这么做。复习一遍pbrt第三版上介绍的方程
$$
f_r = \frac{\rho}{\pi}(C_1 + C_2 \max(0,\cos(\phi_i - \phi_o)))\sin \alpha \tan \beta
$$
但在这些渲染器中，还会用一种更复杂的公式，来源于自论文Generalization of Lambert’s Reflectance Model 。这个公式将bsdf分为直接照明和互反射照明，同样采用近似方法，直接照明近似为
$$
L_r^1 = \frac{\rho}{\pi}E_0\cos \theta_i[C_1 + \cos(\phi_r -\phi_i)C_2\tan\beta + (1-|\cos(\phi_r - \phi_i|)C_3 \tan(\frac{\alpha + \beta}{2})]
$$
互反射近似为
$$
L_r^2 = 0.17\frac{\rho^2}{\pi}\cos \theta_i \frac{\sigma^2}{\sigma^2 + 0.13}(1 - \cos(\phi_r - \phi_i)(\frac{2\beta}{\pi})^2)
$$

### pbrt-v3库

evaluate函数，在pbrt-v3中也叫f函数，在reflection.cpp中如下

```
Spectrum OrenNayar::f(const Vector3f &wo, const Vector3f &wi) const {
...
return R * InvPi * (A + B * maxCos * sinAlpha * tanBeta);}
```



### luxcore库

代码在roughmatte.cpp中，采样函数中，入射方向为cos半球采样。

evaluate函数用的本上pbrt书上所介绍的orennaya方程

```
const float coef = (A + B * maxcos * sinthetai * sinthetao / max(fabsf(CosTheta(*localSampledDir)), fabsf(CosTheta(localFixedDir))));
if (hitPoint.fromLight)
		return Kd->GetSpectrumValue(hitPoint).Clamp(0.f, 1.f) * (coef * fabsf(localFixedDir.z / localSampledDir->z));
else
		return Kd->GetSpectrumValue(hitPoint).Clamp(0.f, 1.f) * coef;
```

概率密度函数则根据光线是否来自光源判断了一下

```
if (directPdfW)
	*directPdfW = fabsf((hitPoint.fromLight ? localEyeDir.z : localLightDir.z) / M_PI 
if (reversePdfW)
	*reversePdfW = fabsf((hitPoint.fromLight ? localLightDir.z : localEyeDir.z) / M_PI 
```

### appleseed库

光线方向仍然是半球cos采样，概率密度函数也仍然是简单的cos_in / pi。 

而在evaluate 中计算反射率的代码如下，可以看出来使用了较为复杂的近似。

```
if(mat_roughness != 0.0)
{
    // Direct illumination component.
    Lr1 = reflectance * reflectance_multiplier / M_PI *  (C1
         + delta_cos_phi * C2 * std::tan(beta)
          + (1.0f - std::abs(delta_cos_phi)) * C3 * std::tan(0.5f * (alpha + beta)));
    // Add interreflection component.
    Lr2 = m_reflectance * m_reflectance * 0.17f * square(reflectance_multiplier) 
                    * sigma2 / (sigma2 + 0.13f)/  M_PI
                    * (1.0f - delta_cos_phi * square(2.0f * beta * RcpPi<float>()));
    sample_beauty = Lr1 + Lr2
}else
{   // Revert to Lambertian when roughness is zero.
	sample_beauty = m_reflectance / M_PI;  
}

```

### mitsuba库

在roughdiffuse.cpp中，计算evaluate时，用了两种方法，分别是brdf版本的快速近似，与appleseed版本的复杂近似。

```
if(m_useFastApprox)
{
	return m_reflectance->eval(bRec.its)* (INV_PI * Frame::cosTheta(bRec.wo) * (A 
			+ B	* std::max(cosPhiDiff, (Float) 0.0f) * sinAlpha * tanBeta));
}else
{
	Spectrum rho = m_reflectance->eval(bRec.its),
         snglScat = rho * (C1 + cosPhiDiff * C2 * tanBeta +
         (1.0f - std::abs(cosPhiDiff)) * C3 * tanHalf),
         dblScat = rho * rho * (C4 * (1.0f - cosPhiDiff*tmp3*tmp3));
	return  (snglScat + dblScat) * (INV_PI * Frame::cosTheta(bRec.wo));
}

```

### tungsten库

在OrenNayarBsdf.cpp中，所采用的策略与pbrt书第三版策略是一样的，同样根据概率判断，足够光滑则均匀半球采样，否则cos半球采样。

```
float ratio = clamp(roughness, 0.01f, 1.0f);
    if (event.sampler->nextBoolean(ratio))
        event.wo  = SampleWarp::uniformHemisphere(event.sampler->next2D());
    else
        event.wo  = SampleWarp::cosineHemisphere(event.sampler->next2D());
```

evaluate函数与众不同，不仅使用了较为复杂的近似，还为直接照明和互反射照明添加了不同的因子

```
float fr1 = (C1 + cosDeltaPhi*C2*std::tan(beta) + (1.0f - 
			std::abs(cosDeltaPhi))*C3*std::tan(0.5f*(alpha + beta)));
float fr2 = 0.17f*sigmaSq/(sigmaSq + 0.13f)*(1.0f - 
			cosDeltaPhi*sqr((2.0f*INV_PI)*beta));
Vec3f diffuseAlbedo = albedo(event.info);
return (diffuseAlbedo*fr1 + diffuseAlbedo*diffuseAlbedo*fr2)*wo.z()*INV_PI;
```

pdf函数

```
event.pdf = SampleWarp::uniformHemispherePdf(event.wo)*ratio + SampleWarp::cosineHemispherePdf(event.wo)*(1.0f - ratio);
```

# 概率材质

## Glossy

glossy则是不那么完美的反射

<img src="E:\mycode\collection\定理\源码阅读\image-20211121225733930.png" alt="image-20211121225733930" style="zoom: 25%;" />

上图的右上就是glossy，左下就是完美反射。主流开源渲染库中一般将其表现为镜面反射与漫反射的叠加。

### luxcore库

这个库用三个不同的glossy材质。第一种是glossy2.cpp，假设glossy上有一个没有厚度的透明涂层，光线击中物体上的点的时候，有wCoating的概率击中这个透明涂层，如果击中了，就镜面反射，否则漫反射。

```
const float wCoating = SchlickBSDF_CoatingWeight(ks, localFixedDir);
const float wBase = 1.f - wCoating;
if (passThroughEvent < wBase) {
	// 未击中透明涂层则漫反射
	*localSampledDir = Sgn(localFixedDir.z) * CosineSampleHemisphere();
	baseF = Kd->GetSpectrumValue(hitPoint).Clamp(0.f, 1.f) * INV_PI * 
			fabsf(hitPoint.fromLight ? localFixedDir.z : absCosSampledDir);
	// Evaluate coating BSDF (Schlick BSDF)
	coatingF = SchlickBSDF_CoatingF(hitPoint.fromLight, ks, roughness, anisotropy, 
				multibounce, localFixedDir, *localSampledDir);
	coatingPdf = SchlickBSDF_CoatingPdf();
}else{
	// 击中透明图层则镜面反射，wh 为微表面模型
	*localSampledDir = 2.f * cosWH * wh - localFixedDir;
	coatingF = SchlickBSDF_CoatingSampleF();
	coatingF *= coatingPdf;
	basePdf = absCosSampledDir * INV_PI;
	baseF = Kd->GetSpectrumValue(hitPoint).Clamp(0.f, 1.f) * INV_PI * 
			fabsf(hitPoint.fromLight ? localFixedDir.z : absCosSampledDir);
}

const Spectrum absorption = CoatingAbsorption(cosi, coso, alpha, d);
// coatingF already takes fresnel factor S into account
f = (coatingF + absorption * (Spectrum(1.f) - S) * baseF) / *pdfW;
*pdfW = coatingPdf * wCoating + basePdf * wBase;
```

然后计算bsdf和pdf的时候，要综合考虑透明涂层与基层的影响。另外一种glossycoating材质看不懂。

### yocto库

在yocto_shading.h的sample_transparent()，光线碰到表面后可能会镜面反射，或者反射。

采样有两种可供选择，包括微表面采样和普通采样。微表面采样如下

```
if (rnl < fresnel_dielectric(ior, halfway, outgoing)) {
    auto incoming = reflect(outgoing, halfway);
} else {
    auto reflected = reflect(outgoing, halfway);
    auto incoming  = -reflect(reflected, up_normal);
```

普通采样的入射光线如下

```
if (rnl < fresnel_dielectric(ior, up_normal, outgoing)) {
    return reflect(outgoing, up_normal);
} else { return -outgoing;}
```

这么一看显然是前者更加真实一些了。不使用微表面模型的话，evaluate函数计算如下

```
if (dot(normal, incoming) * dot(normal, outgoing) >= 0) {
    return vec3f{1, 1, 1} * fresnel_dielectric(ior, up_normal, outgoing);
  } else {
    return color * (1 - fresnel_dielectric(ior, up_normal, outgoing));
  }
```

概率密度函数如下

```
if (dot(normal, incoming) * dot(normal, outgoing) >= 0) {
    return fresnel_dielectric(ior, up_normal, outgoing);
  } else {
    return 1 - fresnel_dielectric(ior, up_normal, outgoing);
  }
```

### libYafaRay库

在material_glossy.cc库，同样假设会发生镜面反射和漫反射中一种，但是还考虑各项同性或各项异性的镜面反射，在一次采样中，镜面反射和漫反射会相互影响，镜面反射使用微表面模型，漫反射使用OrenNayar。

```
if(use_diffuse){
	if(s_1 < s_p_diffuse){
		wi = sample::cosHemisphere(n, sp.nu_, sp.nv_, s_1, s.s_2_);
		if(use_glossy){
		    // 使用带各项异性的微表面模型
			if(anisotropic_){
				s.pdf_ = s.pdf_ * cur_p_diffuse +asAnisoPdf() * (1.f - 
							cur_p_diffuse);
				glossy =asAnisoD() * schlickFresnel() / asDivisor();
			}else{
					s.pdf_ = s.pdf_ * cur_p_diffuse + blinnPdf()* (1.f - 
								cur_p_diffuse);
					glossy = blinnD() * schlickFresnel() / asDivisor();}
		scolor = glossy * getShaderColor();
		add_col = diffuseReflect();
		if(oren_nayar_){add_col *= orenNayar();}
		scolor += add_col;
		return scolor;
	}
```

pdf函数中，高光也会使用带各项异性的微表面模型，漫反射则是普通的漫反射

```
if(use_diffuse){
	pdf = std::abs(wi * n);
	if(use_glossy){
		if(anisotropic_){
			const Vec3 hs(h * sp.nu_, h * sp.nv_, cos_n_h);
			pdf = pdf * cur_p_diffuse + asAnisoPdf() * (1.f - cur_p_diffuse);
		}else pdf = pdf * cur_p_diffuse + blinnPdf() * (1.f - cur_p_diffuse);
	}
	return pdf;}
```



## Ashikhmin-Shirley

方向的选择依然是半球采样和完美高光反射，不过为了计算reflectance，也就是rho，在计算各项异性高光反射时需要花点心思。在appleseed库提到的参考论文中，高光反射率是这么算的
$$
\rho_s(\bold k_1,\bold k_2) = \frac{\sqrt{(n_u + 1)(n_v + 1)}}{8\pi}\frac{(\bold n \cdot \bold h)*term}{(\bold h \cdot \bold k)\max((\bold n \cdot \bold k_1),(\bold n \cdot \bold k_2))}F((\bold k,\bold h))
$$
对于各项异性来说
$$
term = \frac{n_u(\bold h \bold u)^2 + n_v(\bold h \bold v)^2}{1 - (\bold h \bold n)^2}
$$
对于各项同性来说
$$
term = n_u
$$
其中n_u和n_v都是参数，n_u越大，代表高光在水平方向上越狭窄，n_v越大代表在竖直方向上越狭窄。

<img src="E:\mycode\collection\定理\源码阅读\image-20211121141818155.png" alt="image-20211121141818155" style="zoom: 67%;" />

### appleseed库

```
bool is_diffuse = rand01() < diffuse_weight;
if(is_diffuse)
{
	incoming = sample_hemisphere_cosine(Vector2f(rand01(), rand1())); // 入射光线方向
	h = normalize(incoming + outgoing.get_value()); // halfway vector
}else{
	if(isotropic)
	{
		exp = m_nu;
	}else
	{
		const float phi = sample_anisotropic_glossy(m_k, s[0]);
		exp = m_nu * cos_phi * cos_phi + m_nv * sin_phi * sin_phi;
	}
	const float cos_theta = std::pow(1.0f - rand01(), 1.0f / (exp + 1.0f));
    const float sin_theta = std::sqrt(1.0f - cos_theta * cos_theta);
    h = local_geometry.m_shading_basis.transform_to_parent(
    Vector3f::make_unit_vector(cos_theta, sin_theta, cos_phi, sin_phi));
	incoming = reflect(outgoing.get_value(), h); 
}
const float cos_in = std::abs(dot(incoming, normal));
const float cos_on = std::abs(dot(outgoing, normal));
const float cos_oh = std::min(std::abs(dot(outgoing, h)), 1.0f);
const float cos_hn = std::abs(dot(h, normal));
if(is_diffuse)
{
	const float a = 1.0f - pow5(1.0f - 0.5f * cos_in);
    const float b = 1.0f - pow5(1.0f - 0.5f * cos_on);
    sample_diffuse = mat_kd * a * b;
    diffuse_pdf = cos_in / M_PI;
}else
{
	onst float num = mat_kg * std::pow(cos_hn, exp);
    const float den = cos_oh * (cos_in + cos_on - cos_in * cos_on);
    sample_glossy = fresnel_reflectance_dielectric_schlick() * num / den;
    glossy_pdf = num / den;
}
bsdf = sample_diffuse + sample_glossy;
```

evaluate函数和pdf函数返回的都是概率密度，计算方法和上面的一样

```
const float probability = diffuse_weight * pdf_diffuse + glossy_weight * pdf_glossy;
return probability;
```

### blender库

大名鼎鼎的blender库中也包含了这种模型。在bsdf_ashikhmin_shirley.h中，

```
if (n_x == n_y) {/* isotropic */
      float e = n_x;
      float lobe = powf(HdotN, e);
      float norm = (n_x + 1.0f) / (8.0f * M_PI_F);
      out = NdotO * norm * lobe * pump;
      /* this is p_h / 4(H.I)  (conversion from 'wh measure' to 'wi measure', eq. 				8 in paper). */
      *pdf = norm * lobe / HdotI;
}else {/* anisotropic */
      if (HdotN < 1.0f) {
        float e = (n_x * HdotX * HdotX + n_y * HdotY * HdotY) / (1.0f - HdotN * HdotN);
        lobe = powf(HdotN, e);}
      else {lobe = 1.0f; }
      float norm = sqrtf((n_x + 1.0f) * (n_y + 1.0f)) / (8.0f * M_PI_F);
      out = NdotO * norm * lobe * pump;
      *pdf = norm * lobe / HdotI;
    }
```

### corona库

在https://github.com/hanatos/corona-13/blob/master/src/shaders/attic/ashi.c中，采样函数分为高光反射和漫反射，高光反射又分为各项同性和异性

```
const float p_s = rs + (1.0f-rs)*powf5(1.0f-nwi); // 高光概率
if(pointsampler(p, s_dim_scatter_mode) < p_s){
    // isotropic specular part
    float phi = 2.0f*M_PI*x1;
#if 1 // 各项同性
    const float cos_phi = cosf(phi), sin_phi = sinf(phi);
#else // aniso:
    cos_phi *= ilen; sin_phi *= ilen;
#endif
    for(int k=0;k<3;k++) wo[k] = wi[k] + 2*hw*h[k];
  }
else //if(rr < p_s + p_d){
    for(int k=0; k<3; k++) wo[k] = sqrtf(x2)*cosf(phi)*u[k] + sqrtf(x2)*sinf(phi)*v[k] + sqrtf(1.0f-x2)*n[k];}
```

evaluate函数则简单分为各项异性和同性

```
#if 1
  float hn = fmaxf(0.0f, h[0]*n[0] + h[1]*n[1] + h[2]*n[2]);
  const float psconst = (nu+1)*powf(hn, nu) / (8*M_PI*fmaxf(nk1,nk2)*hk);
#else // aniso
  float *u = p->v[v].hit.a, *v = p->v[v].hit.b;
  float hu = fabsf(h[0]*u[0] + h[1]*u[1] + h[2]*u[2]);
  float hv = fabsf(h[0]*v[0] + h[1]*v[1] + h[2]*v[2]);
  psconst = sqrtf((nu+1)*(nv+1))*powf(hn,(nu*hu*hu + nv*hv*hv)/(1-hn*hn))
           / (8*M_PI*fmaxf(nk1,nk2)*hk);
#endif
brdf += psconst * fresnel;
```

概率密度函数如下

```
return p_s*(nu+1)*powf(fabsf(dotproduct(n, h)), nu)/(8.0f*M_PI*doto*fabsf(dotproduct(wi, h))) + (1.0-p_s)/M_PI;
```



## 塑料

又称plasticity，主要参考论文为A Physically-Based Reflectance Model Combining Reflection and Diffraction 。假设塑料由两层构成，第一层为会发生高光反射透明层，第二层为发生漫反射不透明层。

如果发生了高光反射，可以使用简单的Cook-Torrance reflectance model ：
$$
\rho = \frac{FDG}{4\cos \theta_i \cos \theta_o}
$$
如果发生了漫反射，那么论文中的公式为
$$
\rho = T\frac{\rho_d}{\pi}(1 - \frac{\rho_d}{\pi}F_{dr}(\frac{1}{\eta}))^{-1}
$$
其中透射率T为
$$
T = (1 - F(\theta_i))(1 - F(\theta_o))
$$

### appleseed库

首先计算会发生高光反射的概率，也就是电介质Fresnel再乘上权重。第一行alpha计算可见首先在第一行根据pbrt第三版第8.4.2节。

```
const float alpha = microfacet_alpha_from_roughness(values->m_roughness);
//return std::max(0.001f, roughness * roughness);
// 菲涅尔方程会告诉我们被反射的光线所占入射光线的百分比
const float Fo = fresnel_reflectance(wo, m, values->m_precomputed.m_eta);
// 相当于F 再乘一个系数，就是塑料材质下高光所占比
const float specular_weight = Fo * m_specular_weight;
const float diffuse_weight = (1.0f - Fo) * m_diffuse_weight;
const float total_weight = specular_weight + diffuse_weight;
const float specular_probability  == 0.0f ? 1.0f : specular_weight / total_weight;
```

如果发生高光反射，就用GGX微表面理论算bsdf。下面的probability就是pdf。

```
if(rand01() < specular_probability){
	const Vector3f m = GGXMDF::sample(wo, Vector2f(rand01(), rand01()), alpha);
	wi = reflect(wo,m);
	//计算高光反射的概率密度函数
	const float cos_wom = dot(wo, m);
	const float jacobian = 1.0f / (4.0f * std::abs(cos_wom));
	const float probability = jacobian * GGXMDF::pdf(wo, m, alpha, alpha) 											*specular_probability;
	//如果确实会发生高光反射
	if (probability > 1.0e-6f){
		 const float denom = std::abs(4.0f * wo.y * wi.y);
         const float D = GGXMDF::D(m, alpha);
         const float G = GGXMDF::G(wi, wo, m, alpha);
         return specular_reflectance * Fo * D * G / denom;
    }}
```

如果光线透射到了第二层并发生漫反射，那么照着公式计算即可

```
else{ //如果当前应该漫反射
	wi = sample_hemisphere_cosine(Vector2f(s[0], s[1]));
	// 计算漫反射的概率密度函数
	const float probability = wi.y / M_PI * (1.0f - specular_probability);
	// 如果确实会发生漫反射
	if (probability > 1.0e-6f){
		const float Fi = fresnel_reflectance(wi, m, values->m_precomputed.m_eta);
		const float eta2 = square(eta);
            const float fdr = fresnel_internal_diffuse_reflectance(1.0f / eta);
            const float T = (1.0f - Fo) * (1.0f - Fi);
            for (size_t i = 0, e = Spectrum::size(); i < e; ++i)
            {
                const float pd = diffuse_reflectance[i];
                const float non_linear_term = 1.0f - lerp(1.0f, pd, internal_scattering) * fdr;
                return  (T * pd * eta2 / M_PI) / non_linear_term;
            }
	}
}
```

pdf函数相比之下很简单，该高光高光，该漫反射漫反射，计算方法和上面的一样

```
jacobian = 1.0f / (4.0f * std::abs(cos_wom));
specular_pdf =  jacobian * GGXMDF::pdf(wo, m, alpha, alpha);
diffuse_pdf = std::abs(wi.y) / M_PI;
```

### mitsuba库

这里没用微表面模型，但是判断是发生高光反射还是漫反射的机制我没看懂，似乎是物体材质指定，可以同时发生？其它的和公式差不多。

```
bool hasSpecular   = (bRec.typeMask & EDeltaReflection)
                && (bRec.component == -1 || bRec.component == 0);
bool hasDiffuse = (bRec.typeMask & EDiffuseReflection)
                && (bRec.component == -1 || bRec.component == 1);
if (hasDiffuse && hasSpecular) {
	Float probSpecular = (Fi*m_specularSamplingWeight) /
          (Fi*m_specularSamplingWeight +(1-Fi) * (1-m_specularSamplingWeight));
	if (sample.x < probSpecular) {
		return m_specularReflectance->eval(bRec.its)* Fi / probSpecular;
    } else {
    	Float Fo = fresnelDielectricExt(Frame::cosTheta(bRec.wo), m_eta);
	 	Spectrum diff = m_diffuseReflectance->eval(bRec.its);
        if (m_nonlinear)	diff /= Spectrum(1.0f) - diff*m_fdrInt;
        else  diff /= 1 - m_fdrInt;
		return diff * (m_invEta2 * (1-Fi) * (1-Fo) / (1-probSpecular));
}else if (hasSpecular) {
    return m_specularReflectance->eval(bRec.its) * Fi;
}else
{
	...
	return diff * (m_invEta2 * (1-Fi) * (1-Fo));
}
```

pdf函数基本上就是高光反射的概率。

```
if (Frame::cosTheta(bRec.wo) <= 0 || Frame::cosTheta(bRec.wi) <= 0)
    {   pdf = 0.0f; return;}
Float Fi = fresnelDielectricExt(Frame::cosTheta(bRec.wi), m_eta);
pdf = (Fi*m_specularSamplingWeight) /
	(Fi*m_specularSamplingWeight +(1-Fi) * (1-m_specularSamplingWeight));
```

mitsuba中也有个粗糙塑料的材质。参考论文Microfacet Models for Refraction through Rough Surfaces'' by Walter et al.

### tungsten库

这里用的是和mitsuba差不多的方式，在PlasticBsdf中，具体逻辑判断略有不同。

```
bool sampleR = event.requestedLobe.test(BsdfLobes::SpecularReflectionLobe);
bool sampleT = event.requestedLobe.test(BsdfLobes::DiffuseReflectionLobe);
float Fi = Fresnel::dielectricReflectance(eta, wi.z());
float substrateWeight = _avgTransmittance*(1.0f - Fi);
float specularWeight = Fi;
if (sampleR && sampleT)
        specularProbability = specularWeight/(specularWeight + substrateWeight);
else if (sampleR)	specularProbability = 1.0f;
else if (sampleT)	specularProbability = 0.0f;
else	return false;
```

采样仍然是cos半球采样和镜面反射组合。evaluate函数与之前两个库是一样的，不过参数名称不一样。

```
float Fi = Fresnel::dielectricReflectance(eta, event.wi.z());
float Fo = Fresnel::dielectricReflectance(eta, event.wo.z());
if (evalR && checkReflectionConstraint(event.wi, event.wo)) {
    return Vec3f(Fi);
} else if (evalT) {
    Vec3f diffuseAlbedo = albedo(event.info);
	Vec3f brdf = ((1.0f - Fi)*(1.0f - Fo)*eta*eta*event.wo.z()*INV_PI)*
                (diffuseAlbedo/(1.0f - diffuseAlbedo*_diffuseFresnel));
	if (_scaledSigmaA.max() > 0.0f)
       	brdf *= std::exp(_scaledSigmaA*(-1.0f/event.wo.z() -1.0f/event.wi.z()));
    return brdf;
} else {return Vec3f(0.0f);}
```

pdf函数有五种可能，如果需要同时采样反射和透射，那么就和Fresnel参数有关，否则就是简单的半球采样pdf或1和0。

```
if (sampleR && sampleT) {
   if (checkReflectionConstraint(event.wi, event.wo))return specularProbability;
   else	return SampleWarp::cosineHemispherePdf(event.wo)*(1.0f - 		
    		specularProbability);
} else if (sampleT) { return SampleWarp::cosineHemispherePdf(event.wo);
					//return std::abs(wo.z())*INV_PI;
} else if (sampleR) {
	return checkReflectionConstraint(event.wi, event.wo) ? 1.0f : 0.0f;
} else {	return 0.0f;}
```

tungsten库中还有个粗糙塑料的材质，使用了微表面模型。参见粗糙电介质中的tungsten库。

## 玻璃/电介质

如果说塑料材质是光线在漫反射和高光反射中二选一，那么玻璃材质就是光线在折射中和高光反射二选一了。

与导体相反，电解质既反射光线又折射光线。常见的电解质表面例如空气与水。

### yocto库

采样函数参加yocto_shading.h中的sample_refractive()函数。

简洁的yocto库直接使用Fresnel函数判断是反射还是折射。

```
if (rnl < fresnel_dielectric(rel_ior, up_normal, outgoing)) {
    return reflect(outgoing, up_normal);
} else {
    return refract(outgoing, up_normal, 1 / rel_ior);
}
// yocto_math.h
inline vec3f refract(const vec3f& w, const vec3f& n, float inv_eta) {
  auto cosine = dot(n, w);
  auto k      = 1 + inv_eta * inv_eta * (cosine * cosine - 1);
  if (k < 0) return {0, 0, 0};  // tir
  return -w * inv_eta + (inv_eta * cosine - sqrt(k)) * n;
}
```

evaluate函数也几乎是直接使用Fresnel函数

```
auto entering  = dot(normal, outgoing) >= 0;
auto up_normal = entering ? normal : -normal;
auto rel_ior   = entering ? ior : (1 / ior);
if (dot(normal, incoming) * dot(normal, outgoing) >= 0) {
    return vec3f{1, 1, 1} * fresnel_dielectric(rel_ior, up_normal, outgoing);
} else {
    return vec3f{1, 1, 1} * (1 / (rel_ior * rel_ior)) *
           (1 - fresnel_dielectric(rel_ior, up_normal, outgoing));}
```

概率密度函数直接使用Fresnel函数

```
if (dot(normal, incoming) * dot(normal, outgoing) >= 0) {
    return fresnel_dielectric(rel_ior, up_normal, outgoing);
  } else {
    return (1 - fresnel_dielectric(rel_ior, up_normal, outgoing));
  }
```

yocto库还有一种使用了微表面模型的玻璃材质，仍然很简洁，值得一读。

### mitsuba

概率判断，先判断入射光线方向和出射光线方向是否一致，如果一致则发生高光反射，否则发射折射。

sample函数中，如果发生反射，那么生成镜面反射入射光线，如果发生折射，根据index算就行了。

```
/// Refraction in local coordinates
inline Vector refract(const Vector &wi, Float cosThetaT) const {
        Float scale = -(cosThetaT < 0 ? m_invEta : m_eta);
        return Vector(scale*wi.x, scale*wi.y, cosThetaT);
}
```

evaluate函数中，那么直接让高光反射率乘上入射光线的Fresnel函数即可。如果发生折射，则还需要乘上缩放系数。

```
if (Frame::cosTheta(bRec.wi) * Frame::cosTheta(bRec.wo) >= 0) {
    return m_specularReflectance->eval(bRec.its) * F;
} else {
    /* Radiance must be scaled to account for the solid angle compression
    that occurs when crossing the interface. */
    Float factor = (bRec.mode == ERadiance)? (cosThetaT < 0 ? m_invEta : m_eta) : 1.0f;
    return m_specularTransmittance->eval(bRec.its)  * factor * factor * (1 - F);}
```

pdf函数中，mitsuba库比较特殊，认为高光反射和折射可能同时存在，虽然实际上只能采样一种，但还是要将它们乘上系数菲涅尔系数。

```
if (sampleTransmission && sampleReflection) {
            if (sample.x <= F) 	{pdf = F;}
            else				{pdf = 1 - F;}
else if (sampleReflection) 		{pdf = 1;}
else if	(sampleTransmission)	{pdf = 1;}
```

### pbrt-v3库

在reflection.cpp的FresnelSpecular类，概率判断用FrensnelDielectric。下面是折射光线实现部分。

```
Float cosThetaI = Dot(n, wi);
Float sin2ThetaI = std::max(Float(0), Float(1 - cosThetaI * cosThetaI));
Float sin2ThetaT = eta * eta * sin2ThetaI;
// Handle total internal reflection for transmission
if (sin2ThetaT >= 1) return false;
Float cosThetaT = std::sqrt(1 - sin2ThetaT);
*wt = eta * -wi + (eta * cosThetaI - cosThetaT) * Vector3f(n);
```

evaluate的时候，与上方mitsuba库差不多。不过概率密度函数要简单很多。

```
Float F = FrDielectric(CosTheta(wo), etaA, etaB);
if (u[0] < F) {
    bsdf =  F * R / AbsCosTheta(*wi);
    *pdf = F;
}else{
	 Spectrum ft = T * (1 - F);
	 if (mode == TransportMode::Radiance)
            ft *= (etaI * etaI) / (etaT * etaT);
	 bsdf = ft / AbsCosTheta(*wi);
	 *pdf = 1 - F;
}
```



### tungesten库

概率判断，算计算Fresnel反射率。如果表面上这一点既允许发生高光反射又允许折射，那么最终反射率就是Fresnel反射率。如果仅允许发射高光，那么反射率为1，反之为零。

sample函数，反射和折射用的是本地坐标

```
float F = Fresnel::dielectricReflectance(eta, std::abs(event.wi.z()), cosThetaT);
float reflectionProbability;
if (sampleR && sampleT)reflectionProbability = F;
else if (sampleR)reflectionProbability = 1.0f;
else if (sampleT) reflectionProbability = 0.0f;
else return false;
if (event.sampler->nextBoolean(reflectionProbability)) {
        event.wo = Vec3f(-event.wi.x(), -event.wi.y(), event.wi.z());
}else{
		event.wo = Vec3f(-event.wi.x()*eta, -event.wi.y()*eta, 
		-std::copysign(cosThetaT, event.wi.z()));}
```

evaluate函数，也是判断入射光线与出射光线的角度。这里的高光反射率叫做albedo。

```
if (event.wi.z()*event.wo.z() >= 0.0f) {
        if (evalR && checkReflectionConstraint(event.wi, event.wo))
            return F*albedo(event.info);
        else return Vec3f(0.0f);
} else {
        if (evalT && checkRefractionConstraint(event.wi, event.wo, eta, cosThetaT))
            return (1.0f - F)*albedo(event.info);
        else return Vec3f(0.0f);}
```

pdf函数很简单，与反射概率呈线性关系

```
if (event.sampler->nextBoolean(reflectionProbability)) {
	event.pdf = reflectionProbability;
}else{
	event.pdf = 1.0f - reflectionProbability;
}
```

### appleseed库

在appleseed还考虑各项同性或异性的玻璃材质，贴代码的原因是，源代码比这长很多，不如直接看下面我整理好的代码。

```
const float eta = wo.y > 0.0f
                    ? values->m_ior / values->m_precomputed.m_outside_ior
                    : values->m_precomputed.m_outside_ior / values->m_ior;
if (APPLESEED_UNLIKELY(eta == 1.0f)) return;
const float square_roughness = m_roughness * m_roughness;
if (m_anisotropy >= 0.0f) 
{
	const float aspect = std::sqrt(1.0f - m_anisotropy * 0.9f);
    alpha_x = std::max(0.001f, square_roughness / aspect);
    alpha_y = std::max(0.001f, square_roughness * aspect);
}
else
{
    const float aspect = std::sqrt(1.0f + anisotropy * 0.9f);
    alpha_x = std::max(0.001f, square_roughness * aspect);
    alpha_y = std::max(0.001f, square_roughness / aspect);
}
const Vector3f m = GGXMDF::sample(wo, Vector2f(rand01(), rand01()), alpha_x, alpha_y);
const float rcp_eta = 1.0f / eta;
const float cos_wom = clamp(dot(wo, m), -1.0f, 1.0f);
const float F = fresnel_reflectance(cos_wom, rcp_eta, cos_theta_t);
const float r_probability = choose_reflection_probability(F);
bool is_reflection = rand01() < r_probability;
if(is_reflection)
{
	wi = improve_normalization(reflect(wo, m));
	// If incoming and outgoing are on different sides of the surface, 
	// this is not a reflection.
    if (wi.y * wo.y <= 0.0f)return;
    const float denom = std::abs(4.0f * wo.y * wi.y);
    const float D = GGXMDF::D(m, alpha_x, alpha_y);
    const float G = GGXMDF::G(wi, wo, m, alpha_x, alpha_y);
    f = mat_reflection_color * F * D * G / denom;
}else
{
	//计算折射方向
	wi = normalize(cos_wom > 0.0f
                ? (rcp_eta * cos_wom - cos_theta_t) * m - rcp_eta * wo
                : (rcp_eta * cos_wom + cos_theta_t) * m - rcp_eta * wo)
	// 计算m_beauty
	const float cos_ih = dot(m, wi);
    const float cos_oh = dot(m, wo);
    const float dots = (cos_ih * cos_oh) / (wi.y * wo.y);
    sqrt_denom = cos_oh + eta * cos_ih;
    const float D = GGXMDF::D(m, alpha_x, alpha_y);
    const float G = GGXMDF::G(wi, wo, m, alpha_x, alpha_y);
    const float T = 1 - F; // F 是被反射的部分，那么T就是被折射的部分
    f = mat_refraction_color * std::abs(dots) * T * D * G / square(sqrt_denom);
}
```

接下来的BSDF值与pdf值的计算是一样，也是反射和折射分开计算。注意在塑料材质，漫反射和高光反射的概率密度最后要相加在一起，但在玻璃材质中，它们并没有加在一起。

```
if(is_reflection)
{
	jacobian = 1.0f / (4.0f * std::abs(cos_oh));
	pdf = r_probability * jacobian * GGXMDF::pdf(wo, m, alpha_x, alpha_y);
}else
{
	const float sqrt_denom = cos_oh + eta * cos_ih;
    if (std::abs(sqrt_denom) < 1.0e-6f)return 0.0f;
    const float jacobian = std::abs(cos_ih) * square(eta / sqrt_denom);
    pdf =  (1 - r_probability) * jacobian * GGXMDF::pdf(wo, m, alpha_x, alpha_y);
}
```

上面的代码中，反射部分的bsdf来源于Microfacet Models for Refraction through Rough Surfaces  的第15个公式，即
$$
f_r^m(\bold i,\bold o,\bold m) = F(\bold i,\bold m)\frac{\delta_{w_m}(\bold h_r,\bold m)}{4(\bold i \cdot \bold h_r)^2}
$$
折射的部分则来源于第18个公式
$$
f_t^m(\bold i,\bold o,\bold m) = (1-F(\bold i,\bold m))\frac{\delta_{w_m}(\bold h_t,\bold m)\eta_o^2}{(\eta_i(\bold i \cdot \bold h_t) + \eta_o(\bold o \cdot \bold h_t))^2}
$$
appleseed库中的r_probability值其实类似于fresnel值。在之前塑料材料的地方说过，受到物体本身折射反射的权重的影响。

```
const float r_probability = F * reflection_weight;
const float t_probability = (1.0f - F) * refraction_weight;
const float sum_probabilities = r_probability + t_probability;
return sum_probabilities != 0.0f ? r_probability / sum_probabilities : 1.0f;
```

### luxcore库

在roughglass.cpp中，也考虑了各项同性和异性。采样时几乎是55开

```
if (!isKrBlack) {if (!isKtBlack)threshold = .5f;
				else threshold = 0.f;
} else {		if (!isKtBlack)threshold = 1.f;
else			return Spectrum();}
if (passThroughEvent < threshold) {
	*localSampledDir = length * wh - eta * localFixedDir;// Transmit}
else{*localSampledDir = 2.f * cosThetaOH * wh - localFixedDir;//reflect	}
```

evaluate的时候，概率密度函数又变了，并且使用微表面模型，微表面模型需要考虑各项同性和异性。并且玻璃上可能还贴着一层薄膜。

```
if (localLightDir.z * localEyeDir.z < 0.f) {// Transmit
	const float D = SchlickDistribution_D(roughness, wh, anisotropy);
	const float G = SchlickDistribution_G(roughness, localLightDir, localEyeDir);
	const Spectrum result = (fabsf(cosThetaOH) * cosThetaIH * D *
			G / (cosThetaI * lengthSquared)) *
			kt * (1.f - F);
}else{
	const float D = SchlickDistribution_D(roughness, wh, anisotropy);
	const float G = SchlickDistribution_G(roughness, localLightDir, localEyeDir);
	if (localFilmThickness > 0.f) {
		return result * CalcFilmColor(localFilmThickness, localFilmIor);}
	return result;
}
```

概率密度函数就是shlick分布的概率密度，也需要考虑各项异性。

## 粗糙电介质

### mitusba库

mitsuba将电介质分为了普通电介质和粗糙电介质材质，前者没有使用微表面模型，后者使用了微表面模型。折射部分参考Microfacet Models for Refraction through Rough Surfaces'' by Walter et al。

evaluate函数部分如下：

```
/* Evaluate the microfacet normal distribution */
const Float D = distr.eval(H);
 if (D == 0)return Spectrum(0.0f);
const Float F = fresnelDielectricExt(dot(bRec.wi, H), m_eta);
/* Smith's shadow-masking function */
const Float G = distr.G(bRec.wi, bRec.wo, H);
if (reflect) {
	return m_specularReflectance->eval(bRec.its) *  F * D * G /
                (4.0f * std::abs(Frame::cosTheta(bRec.wi)));
} else {
    Float eta = Frame::cosTheta(bRec.wi) > 0.0f ? m_eta : m_invEta;
	/* Calculate the total amount of transmission */
    Float sqrtDenom = dot(bRec.wi, H) + eta * dot(bRec.wo, H);
    Float value = ((1 - F) * D * G * eta * eta* dot(bRec.wi, H) * dot(bRec.wo, H)) /
                (Frame::cosTheta(bRec.wi) * sqrtDenom * sqrtDenom);
	/* Missing term in the original paper: account for the solid angle compression 	
		when tracing radiance -- this is necessary for bidirectional methods */
    Float factor = (bRec.mode == ERadiance)
    ? (Frame::cosTheta(bRec.wi) > 0 ? m_invEta : m_eta) : 1.0f;
return m_specularTransmittance->eval(bRec.its)* std::abs(value * factor * factor);}
```

### tungsten库

在RoughDielectricBsdf.cpp中，也同样了使用微表面模型。由此总结可知，开源渲染器中，很多材质都可分为光滑和粗糙两类，光滑版本的不使用微表面模型，粗糙版本的使用微表面模型即可。这种知识在书上绝对是看不到的。

这个库将控制参数写得很清楚，包括

ior，折射率，用于计算折射时的光线采样和bsdf。

enableT，是否启用透射。

roughness，用于计算微表面模型的法向量。

概率判断时，相比光滑电介质判断简单很多

```
if (sampleR && sampleT) {
      reflect = event.sampler->nextBoolean(F);
} else if (sampleT) {
      if (F == 1.0f)return false;
      reflect = false;
} else if (sampleR) { reflect = true;
} else {return false;}
```

采样光线，根据注释来看，某篇论文上的公式似乎有错误？

```
Vec3f m = Microfacet::sample(distribution, sampleAlpha, event.sampler->next2D());
float pm = Microfacet::pdf(distribution, sampleAlpha, m);
float wiDotM = event.wi.dot(m);
float woDotN = event.wo.z();

if (reflect)
        event.wo = 2.0f*wiDotM*m - event.wi;
        // Version from the paper (wrong!)
        //event.wo = 2.0f*std::abs(wiDotM)*m - event.wi;
else
        event.wo = (etaM*wiDotM - sgnE(wiDotM)*cosThetaT)*m - etaM*event.wi;
        // Version from the paper (wrong!)
        //event.wo = (etaM*wiDotM - sgnE(wiDotN)*std::sqrt(1.0f + etaM*(wiDotM*wiDotM - 1.0f)))*m - etaM*event.wi;
```

evaluate函数

```
if (reflect) {
    float fr = (F*G*D*0.25f)/std::abs(wiDotN);
    return Vec3f(fr);
} else {
    float fs = std::abs(wiDotM*woDotM)*(1.0f - F)*G*D/(sqr(eta*wiDotM + woDotM)*std::abs(wiDotN));
    return Vec3f(fs);}
```

pdf函数

```
if (reflect)pdf = pm*0.25f/std::abs(wiDotM);
else	pdf = pm*std::abs(woDotM)/sqr(eta*wiDotM + woDotM);
if (sampleR && sampleT) {
    if (reflect) pdf *= F;
    else pdf *= 1.0f - F;}
```

### libyafaray库

在material_rough_glass.cc中、evaluate主要部分如下

```
if(s.s_1_ < kt && s.flags_.hasAny(BsdfFlags::Transmit))
{
	float ht = ior_wo * wo_h + ior_wi * wi_h;
	const float jacobian = (ior_wi * ior_wi) / std::max(1.0e-8f, ht * ht);
	const float glossy = std::abs((wo_h * wi_h) / (wi_n * wo_n)) * kt * glossy_g * glossy_d * jacobian;
	ret = glossy * getShaderColor(filter_col_shader_, mat_data->node_tree_data_, filter_color_);
	s.pdf_ = microfacet::ggxPdf();
}else
{
	const float jacobian = 1.f / std::max(1.0e-8f, (4.f * std::abs(wi_h)));
	const float glossy = (kr * glossy_g * glossy_d) / std::max(1.0e-8f, (4.f * std::abs(wo_n * wi_n)));
	ret = glossy * getShaderColor();
	s.pdf_ = microfacet::ggxPdf(glossy_d, cos_theta, jacobian);
}

```



### corona-13库

在https://github.com/hanatos/corona-13/blob/master/src/shaders/attic/roughdielectric.c中，概率判断简单的用了fresnel函数，光线采样和pdf都没有使用微表面模型。

```
const float cosr = -dotproduct(p->e[v].omega, h);//反射角度
const float cost2 = 1.0f - eta_ratio * eta_ratio * (1.0f - cosr * cosr);
const float cost = (cost2 <= 0.0f) ? 0.0f : sqrtf(cost2);//折射角度
const float R = fresnel(n1, n2, cosr, cost);
pdf = 1;
if (pointsampler(p, s_dim_scatter_mode) < R)
{
	for (int k = 0; k < 3; k++)
      p->e[v + 1].omega[k] = p->e[v].omega[k] + 2.0f * cosr * h[k];
    pdf = pdf * R / 4 / cosr;
}else
{
	for (int k = 0; k < 3; k++)
      p->e[v + 1].omega[k] = p->e[v].omega[k] * eta_ratio + f * h[k];
    normalise(p->e[v + 1].omega);
    pdf *= (1.0 - R);
    const float denom = n1 * cosr - n2 * cost;
    pdf *= n2 * n2 * cost / (denom * denom);
}
```

计算bsdf的时候，其中R是Fresnel函数，G是阴影参数

```
if (p->v[v].mode & s_reflect){
    if (cos_in == 0.0f)return 0.0f;
    if (p->v[v].mode & s_glossy)
      return p->v[v].shading.rg * R * d * G / (4.0f * fabsf(cos_in * cos_out));
    // now check dot to outgoing dir for pure specular case
    if (cosh < HALFVEC_COS_THR)return 0.0f;
    if (cost2 < 0.0f)return p->v[v].shading.rg;
    return p->v[v].shading.rg * R;
}else{
    const float denom = n1 * cosr - n2 * cost;
    if (cos_in == 0.0f || denom * denom == 0.0f)return 0.0f;
    if (p->v[v].mode & s_glossy)
      return p->v[v].shading.rg * (1 - R) * d * G * n2 * n2 * cosr * cost / (fabsf(cos_in * cos_out) * denom * denom);
    // pure specular case
    if (cosh < HALFVEC_COS_THR)return 0.0f;
    return p->v[v].shading.rg * fmaxf(0.0f, 1.0f - R);
  }
```

## FresnelBlend

这种材质是多层材质，上层为glossy specular，下层为漫反射。来源于Ashikhmin and Shirley
(2000, 2002) 。在pbrt第三版551页，高光反射项为
$$
f_r(p,w_o,w_i) = \frac{D(w_h)F(w_o)}{4(w_h \cdot w_i)(\max((\bold n \cdot w_o),(\bold n \cdot w_i)))}
$$
漫反射项为
$$
f_d(p,w_i,w_o) = \frac{28 R_d}{23\pi}(1-R_s)(1-(1-\frac{(\bold n \cdot w_i)}{2})^5)(1-(1-\frac{(\bold n \cdot w_o)}{2})^5)
$$
这种材质的名字好像很多，可以叫FresnelBlend，又可以叫phong。这种材质最特别的就是那个28 / 23这一项。如果所以我看到28 / 23这一项，就默认为这个材质了。

### pbrt-v3

在reflection.cpp中，概率判断五五开。

```
if (u[0] < .5) {
    *wi = CosineSampleHemisphere(u);
    if (wo.z < 0) wi->z *= -1;
} else {
    *wi = Reflect(wo, wh);
}
```

evaluate函数，则是漫反射项与高光项的bsdf相加

```
Spectrum diffuse = (28.f / (23.f * Pi)) * Rd * (Spectrum(1.f) - Rs) *
                       (1 - pow5(1 - .5f * AbsCosTheta(wi))) *
                       (1 - pow5(1 - .5f * AbsCosTheta(wo)));
Spectrum specular =
        distribution->D(wh) /
        (4 * AbsDot(wi, wh) * std::max(AbsCosTheta(wi), AbsCosTheta(wo))) *
        SchlickFresnel(Dot(wi, wh));
return diffuse + specular;
```

概率密度函数也不复杂，使用了微表面模型。

```
return .5f * (AbsCosTheta(wi) * InvPi + pdf_wh / (4 * Dot(wo, wh)));
```

### BRDF-Explorer库

在ashikhman_shirley.brdf中，主要代码为

```
float F = Fresnel(Rs, HdotV);
float norm_s = sqrt((nu+1)*((isotropic?nu:nv)+1))/(8*PI);
float n = isotropic ? nu :(nu*sqr(HdotX) + nv*sqr(HdotY))/(1-sqr(NdotH));
float rho_s = norm_s * F * pow(max(NdotH,0), n) / (HdotV * max(NdotV, NdotL));

float rho_d = 28/(23*PI) * Rd * (1-pow(1-NdotV/2, 5)) * (1-pow(1-NdotL/2, 5));
if (coupled_diffuse) rho_d *= (1-Rs);
 return vec3(rho_s + rho_d);
```



### corona

在https://github.com/hanatos/corona-13/blob/master/src/shaders/attic/phong.c中，采样函数如下

```
if(rr < get_fresnel())
{
    // fake reflection
    if(2.0f*rr < f)
    {
      for(int k=0;k<3;k++) out[k] = in[k] + 2*cos_theta_in*hit->normal[k];
      return 2.0f*get_spectrum(s, s->r, hit->lambda);
    }
    // specular part
    for(int k=0;k<3;k++) h[k] = z*hit->normal[k] + x*hit->a[k] + y*hit->b[k];
    const float hk = - dotproduct(in, h);
    for(int k=0;k<3;k++) out[k] = in[k] + 2*hk*h[k];
    const float fcorr = get_fresnel();
    return 2.0f*fcorr*get_spectrum()/fmaxf(cos_theta_in, cos_theta_out);
}else{
    for(int k=0; k<3; k++) out[k] = z*hit->normal[k] + x*hit->a[k] + y*hit->b[k];
  	const float fcorr = (1.0f - get_fresnel());
    return (28.0f/23.0f) * fcorr * get_spectrum(); time.}
```

bsdf计算如下

```
phong_brdf = (k+1)*powf(dot, k)/(fmaxf(0.001f, -dotproduct(h, in))*fmaxf(-
				dotproduct(n, in), dotproduct(n, out))*8.0f*M_PI);
F  = get_fresnel();
return (1.0f - F)*28.0*get_spectrum()/(23.0f*M_PI) +F*get_spectrum()*phong_brdf();
```

pdf计算如下

```
if(rr < fresnel())return (k+1)*powf(dotproduct(hit->normal, h), 
						k)/(8.0f*M_PI*dotproduct(omega_in, h));
else return dotproduct(hit->normal, omega_out)/M_PI;
```



## 薄膜

又称thinsheet或thinfilm。

### tungsten库

在ThinSheetBsdf.cpp中，假设材质为单层非常薄的材质，内部仍然可以反射和折射，甚至会有光谱干涉的发生。

sample函数中，入射光线为本地反射

```
event.wo = Vec3f(-event.wi.x(), -event.wi.y(), event.wi.z());
```

evaluate函数，允许干涉现象。

```
if (_enableInterference) {
        transmittance = 1.0f - Fresnel::thinFilmReflectanceInterference(1.0f/_ior,
                std::abs(event.wi.z()), thickness*500.0f, cosThetaT);
 else {
        transmittance = Vec3f(1.0f - Fresnel::thinFilmReflectance(1.0f/_ior, std::abs(event.wi.z()), cosThetaT));}
if (_sigmaA != 0.0f && cosThetaT > 0.0f)
        transmittance *= std::exp(-_sigmaA*(thickness*2.0f/cosThetaT));
return transmittance;
```

上面的薄膜Fresnel计算较为复杂，参加库中的Fresnel.hpp和http://www.gamedev.net/page/resources/_/technical/graphics-programming-and-theory/thin-film-interference-for-computer-graphics-r2962。

概率密度函数，则简单判断是否会发生折射。

```
    bool sampleR = event.requestedLobe.test(BsdfLobes::SpecularReflectionLobe);
    if (sampleR && checkReflectionConstraint(event.wi, event.wo))
        return 1.0f;
    else
        return 0.0f;
```

## 透明涂层

又称coating。

### filament库

filament的文档对此解释非常详细，代码请见shading_model_standard.fs。

### tungsten库

在SmoothCoatBsdf.cpp中，与玻璃很相似，其中判断到底是发生反射还是折射时，用的方法与塑料材质完全一致。

```
bool sampleR = event.requestedLobe.test(BsdfLobes::SpecularReflectionLobe);
bool sampleT = event.requestedLobe.test(BsdfLobes::DiffuseReflectionLobe);
float Fi = Fresnel::dielectricReflectance(eta, wi.z());
float substrateWeight = _avgTransmittance*(1.0f - Fi);
float specularWeight = Fi;
if (sampleR && sampleT)
        specularProbability = specularWeight/(specularWeight + substrateWeight);
else if (sampleR)	specularProbability = 1.0f;
else if (sampleT)	specularProbability = 0.0f;
else	return false;
```

采样函数中，反射仍然是镜面反射，但是折射会同时修改入射光线和出射光线。

```
if (sampleR && event.sampler->nextBoolean(specularProbability)) {
	event.wo = Vec3f(-wi.x(), -wi.y(), wi.z());
}else{
	Vec3f originalWi(wi);
    Vec3f wiSubstrate(wi.x()*eta, wi.y()*eta, cosThetaTi);
    event.wi = wiSubstrate;
    bool success = _substrate->sample(event);
    event.wi = originalWi;
    event.wo = Vec3f(event.wo.x()*_ior, event.wo.y()*_ior, cosThetaTo);
}
```

evaluate稍微复杂一些

```
if (evalR && checkReflectionConstraint(event.wi, event.wo)) {
     return Vec3f(Fi);
} else if (evalT) {
     Vec3f wiSubstrate(wi.x()*eta, wi.y()*eta, copysign(cosThetaTi, wi.z()));
     Vec3f woSubstrate(wo.x()*eta, wo.y()*eta, copysign(cosThetaTo, wo.z()));
	float laplacian = eta*eta*wo.z()/cosThetaTo;
	 Vec3f substrateF = _substrate->eval(event.makeWarpedQuery(wiSubstrate, woSubstrate));
	if (_scaledSigmaA.max() > 0.0f)
         substrateF *= std::exp(_scaledSigmaA*(-1.0f/cosThetaTo - 1.0f/cosThetaTi));
        return laplacian*(1.0f - Fi)*(1.0f - Fo)*substrateF;
} else {return Vec3f(0.0f);}
```

pdf函数也没看懂

```
if (sampleR && sampleT) {
     float substrateWeight = _avgTransmittance*(1.0f - Fi);
     float specularWeight = Fi;
     float specularProbability = specularWeight/(specularWeight + substrateWeight);
     if (checkReflectionConstraint(event.wi, event.wo))
         return specularProbability;
     else
         return _substrate->pdf(WarpedQuery(wiSubstrate, woSubstrate))
                *(1.0f - specularProbability)*eta*eta*std::abs(wo.z()/cosThetaTo);
} else if (sampleT) {
        return _substrate->pdf(WarpedQuery(wiSubstrate, 
        		woSubstrate))*eta*eta*std::abs(wo.z()/cosThetaTo);
} else if (sampleR) {
        return checkReflectionConstraint(event.wi, event.wo) ? 1.0f : 0.0f;
} else {return 0.0f;}
```

还有个粗糙透明涂层看不懂。

### mitsuba库

在coating.cpp中，参考论文为``Arbitrarily Layered Micro-Facet Surfaces'' by Weidlich and Wilkie。

## Translucent材质

半透明材质即外面一层薄透明材质，里面一层不透明材质。

### luxcore库

在LuxCore库中有个很特别的RoughMatteTranslucent材质，也就是半透明的粗表面。kr即为反射，kt就是透射

```
const Spectrum kr = Kr->GetSpectrumValue(hitPoint).Clamp(0.f, 1.f);
const Spectrum kt = Kt->GetSpectrumValue(hitPoint).Clamp(0.f, 1.f) * 
// Energy conservation
		(Spectrum(1.f) - kr);
const Spectrum result = (INV_PI * fabsf(localLightDir.z) *
		(A + B * maxcos * sinthetai * sinthetao / max(fabsf(CosTheta(localLightDir)), fabsf(CosTheta(localEyeDir)))));
if (localLightDir.z * localEyeDir.z > 0.f) {
	*event = DIFFUSE | REFLECT;
	return kr * result;
} else {
	*event = DIFFUSE | TRANSMIT;
	return kt * result;
}
```

注意上面第7行，用的是灯光照射方向与摄像机方向的dot 是否大于零，大于零则说明方向相同，那么反射。否则投射。但是luxcore也在sample函数用另一种方式，即随机数判断是反射还是折射。

对于这种半透明粗表面，luxcore库的概率密度函数比较独特，如下

```
if (!isKrBlack) { if (!isKtBlack)weight = .5f;
                  else weight = 1.f;
} else {
		if (!isKtBlack)weight = 0.f;
		else { 	if (directPdfW) *directPdfW = 0.f;
				if (reversePdfW)*reversePdfW = 0.f;
				return;}}
const bool relfected = (Sgn(CosTheta(localLightDir)) == Sgn(CosTheta(localEyeDir)));
weight = relfected ? weight : (1.f - weight);
if (directPdfW)
*directPdfW = fabsf((hitPoint.fromLight ? localEyeDir.z : localLightDir.z) * (weight * INV_PI));
```

如果kr和kt都不为零，那么各自的权重就为0.5。

# 高级材质

## 布料

matte，sheen和shiny是三种布料的材质。

matte类似于粗布，粗表面，没有反射高光。以审美的角度来看，如果你想让一件物体不太被人注意，隐藏起来，就可以使用matte材质。

sheen则是反射一点高光的布料。以审美的角度来看，如果你想让一件物体能够被人注意，就可以使用sheen材质。根据https://insideoutstyleblog.com/2008/10/fabric-should-i-choose-matte-sheen-or-shine.html，如果你觉得自己今天的脸蛋感到比较满意，就可以穿一条sheen材质的领带。那么大家就会被高光吸引，进而留意到你的惊世骇俗的脸蛋了。

shiny则是反射很多高光的布料。如果你想让一件物体快速被人注意，成为舞台上的主角，就可以使用shiny材质。不过显然，shiny材质用的太多也不好。

不过在pbrt第三版说，可以一个参数sigma来控制材质的粗糙程度，如果sigma为零，那么就是lambetian反射模型，否则就是OrenNayar模型。不过也有很多开源渲染引擎并没有这个控制参数，而是直接使用了OrenNayar模型，但是材质名字仍然叫matte。

除此之外还有天鹅绒velvet，编制物woven，纱线yarn等。

### filament库

filament用的是光栅化着色器下的微表面模型，详见shading_model_cloth.fs，代码很简洁，filament库的文档也写得很清楚。

### falcor库

falcor的ClothBRDF.slang给出一些参考论文，包括 \- Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886".  \- Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". 代码实现也很简洁约100行。地址https://github.com/NVIDIAGameWorks/Falcor/blob/master/Source/Falcor/Experimental/Scene/Material/ClothBRDF.slang。

### luxcore库

在cloth.cpp中，精细到了纱线(yarn)，可以为经纬线(warp and weft)提高渲染。主要代码约250行，未提供参考论文。

### mitsuba

具体请参考mitsuba库的irawan.cpp。可以模拟编织物(woven)。sample函数和pdf函数和漫反射的一样，不过evaluate函数很复杂，代码中注释很详细，且附有参考论文，这里就不贴了。

## Sheen

sheen也是布料的一种。

### appleseed库

在sheenbrdf.cpp中非常简单，参考论文为https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf。采样只有cos半球采样。evaluate和概率密度函数归纳如下

```
bsdf = m_reflectance * m_multiplier * pow_int<5>(saturate(1.0f - cos_ih));
pdf = 0.5 / PI;
```

### blender库

代码在bsdf_principled_sheen.h中。参考论文为Shading model by Brent Burley (Disney): "Physically Based Shading at Disney" (2012)。

采样光线为cos半球采样。evaluate函数很简单

```
float LdotH = dot(L, H);
float value = schlick_fresnel(LdotH) * NdotL;
return make_float3(value, value, value);
```

pdf函数计算如下

```
*pdf = fmaxf(dot(N, omega_in), 0.0f) * M_1_PI_F;
```

## 天鹅绒

### luxcore

在velvet.cpp中，入射光线法向为半球上cos采样，概率密度函数参见之前的orennaya材质。其evaluate函数返回的结果如下

```
const float cosv = -Dot(localFixedDir, *localSampledDir);
// Compute phase function
const float B = 3.0f * cosv;
float p = 1.0f + A1 * cosv + A2 * 0.5f * (B * cosv - 1.0f) + A3 * 0.5 * (5.0f * cosv * cosv * cosv - B);
p = p / (4.0f * M_PI);
p = (p * delta) / (hitPoint.fromLight ? fabsf(localSampledDir->z) : fabsf(localFixedDir.z));
// Clamp the BRDF (page 7)
if (p > 1.0f)p = 1.0f;
else if (p < 0.0f)p = 0.0f;
return Kd->GetSpectrumValue(hitPoint).Clamp(0.f, 1.f) * (p / *pdfW);
```

### blender库

在bsdf_ashikhmin_velvet.h中，采样方向为cos半球采样，evaluate函数主体如下

```
float fac1 = 2 * fabsf(cosNHdivHO * cosNO);
float fac2 = 2 * fabsf(cosNHdivHO * cosNI);
float sinNH2 = 1 - cosNH * cosNH;
float sinNH4 = sinNH2 * sinNH2;
float cotangent2 = (cosNH * cosNH) / sinNH2;
float D = expf(-cotangent2 * m_invsigma2) * m_invsigma2 * M_1_PI_F / sinNH4;
float G = min(1.0f, min(fac1, fac2));  // TODO: derive G from D analytically
float out = 0.25f * (D * G) / cosNO;
return make_float3(out, out, out);
```

概率密度函数为

```
*pdf = 0.5f * M_1_PI_F;
```

## 头发

### tungesten库

在LambetianFiberBcsdf.cpp中，散射理论是完美Lambertian圆柱体，请参考"Light Scattering from Filaments"和"Importance Sampling for Physically-Based Hair Fiber Models"。

入射光线计算如下

```
float h = event.sampler->next1D()*2.0f - 1.0f;
    float nx = h;
    float nz = trigInverse(nx);
    Vec3f d = SampleWarp::cosineHemisphere(event.sampler->next2D());
    event.wo = Vec3f(d.z()*nx + d.x()*nz, d.y(), d.z()*nz - d.x()*nx);
```

evaluate函数也使用Lambertian圆柱体。

```
static inline float trigInverse(float x){
    return min(std::sqrt(max(1.0f - x*x, 0.0f)), 1.0f);}

inline float LambertianFiberBcsdf::lambertianCylinder(const Vec3f &wo) const{
    float cosThetaO = trigInverse(wo.y());
    float phi = std::atan2(wo.x(), wo.z());
    if (phi < 0.0f)
        phi += TWO_PI;
    return cosThetaO*std::abs(((PI - phi)*std::cos(phi) + std::sin(phi))*INV_FOUR_PI);}

Vec3f LambertianFiberBcsdf::eval(const SurfaceScatterEvent &event) const{
    if (!event.requestedLobe.test(BsdfLobes::DiffuseLobe))
        return Vec3f(0.0f);
    event.pdf = lambertianCylinder(event.wo);
    return albedo(event.info)*lambertianCylinder(event.wo);}
```

还有另一种HairBcsdf.cpp中，计算较为复杂，代码注释详细，细节请看论文Light Scattering from Human Hair Fibers。

### blender库

bsdf_hair.h实现较为简洁约200行代码。

bsdf_principle.h较复杂约500行代码。

### appleseed库

在hairbsdf.cpp较为复杂约600行代码。

### falcor库

在HairChiang16.slang中，地址https://github.com/NVIDIAGameWorks/Falcor/blob/master/Source/Falcor/Experimental/Scene/Material/HairChiang16.slang，参考论文为Hair BCSDF from "A Practical and Controllable Hair and Fur Model for Production Path Tracing", Chiang et al. 2016。不过代码较多约500行。

## 车漆

### luxcore库

在carpaint.cpp中，主要代码约200行。

### libYafaRay库

在material_coated_glossy.cc上，考虑了各项同性和异性。

## 迪士尼

这种模型最大特点就是只需一个brdf，配上很多参数即可，也可以获得很不错的模拟效果。

### appleseed库

在disneybrdf.cpp中，将材质分成了四个组件，包括DiffuseComponent，SheenComponent，SpecularComponent以及ClearcoatComponent，每个组件有自己权重，最后相加即可。

其中漫反射组件使用Hanrahan-Krueger BRDF approximation。

Sheen组件

高光组件使用漫反射GGX模型。

clearcoat组件使用漫反射GTR1模型。

随机生成采样光线时，顺序如下

```
if (s < cdf[DiffuseComponent]){	DisneyDiffuseComponent().sample();}
else if (s < cdf[SheenComponent]){DisneySheenComponent().sample();}
else if	(s < cdf[SpecularComponent]){MicrofacetBRDFHelper<GGXMDF>::sample();}
else{MicrofacetBRDFHelper<GTR1MDF>::sample();}
```

计算bsdf的时候分为两个部分，包括漫反射部分和高光部分。漫反射来源于漫反射组件，高光来源于剩下三个组件。

计算pdf的时候，根据每个组件的权重将每个组件的pdf相加到一起。

### luxcore库

在disney.cpp中，采样分为金属，clearcoat以及漫反射。金属采样就是镜面反射，但是会考虑到各项异性。clearcoat是一种类似于镜面反射的采样。漫反射采样就是简单的cos半球。

```
if (passThroughEvent <= ratioGlossy)
	*localSampledDir = DisneyMetallicSample();
else if (passThroughEvent > ratioGlossy &&  passThroughEvent <= ratioGlossy + ratioClearcoat)
	*localSampledDir = DisneyClearcoatSample(clearcoatGloss, wo, u0, u1);
else if (passThroughEvent > ratioGlossy + ratioClearcoat && passThroughEvent <= ratioGlossy + ratioClearcoat + ratioDiffuse)
	*localSampledDir = DisneyDiffuseSample(wo, u0, u1);
else	return Spectrum();
```

计算bsdf的时候，则考虑了五种反射模型，包括diffuseEval, subsurfaceEval, metallicEval,  clearCoatEval以及sheenEval。最后用参数插值。

计算概率密度函数的时候，也考虑了三种，分别是diffuseDirectPdfW, metallicDirectPdfW和clearcoatDirectPdfW。

### BRDF-Explorer库

在disney.brdf中，光栅化算法，自家开源程序实现自己经典算法，能不简洁嘛。分为四个部分，漫反射，高光，sheen以及透明涂层。

### PBRVulkan库

代码在https://github.com/Zielon/PBRVulkan/blob/master/PBRVulkan/RayTracer/src/Assets/Shaders/BSDFs/DisneyBSDF.glsl

采样分为透射，漫反射与高光。

evaluate的时候，用的是brdf与bsdf的插值，前者受到漫反射，高光与透明涂层三者的影响，后者受到反射或透射其中之一的影响。

概率密度函数分为透射，漫反射，高光及透明涂层。

# 特殊材质

这里收集的一些材质，包括双面材质，混合材质

## 双面材质

双面材质，即光线从击中物体的前后表面时，会表现出不同的材质效果。

luxcore库仅仅是简单的判断一下击中的是物体的正面还是后面，再调用相应材质的函数。函数在twosided.cpp中。

```
if (hitPoint.intoObject)
		return frontMat->Evaluate(hitPoint, localLightDir, localEyeDir, event, directPdfW, reversePdfW);
	else
		return backMat->Evaluate(hitPoint, localLightDir, localEyeDir, event, directPdfW, reversePdfW);
```

mitsuba库的twosided.cpp中，基本上也是根据入射光线与法向量的点积来决定要采样哪一边的材质。

## 混合blend/Mix材质

混合材质，就是光线击中的某点上，既有某种材质，也有另一种材质，不过百分比不同而已。

在tungsten库中的，MixedBsdf.cpp中，采样时，根据两种材质的权重，来选择一个采样入射光线。

而bsdf以及概率密度则结合两种材质，并乘上不同的权重。

```
if (event.sampler->nextBoolean(ratio)) {event.sampler->nextBoolean(ratio)}
else{_bsdf1->sample(event)}
f = albedo(event.info)*(_bsdf0->eval(event)*ratio + _bsdf1->eval(event)*(1.0f - ratio));
pdf = _bsdf0->pdf(event)*ratio + _bsdf1->pdf(event)*(1.0f - ratio);
```

其它的库包括filament, appleseed和mitsuba库都实现了这种材质。

mitsuba库还有各mixturebsdf.cpp，可以混合两个以上的材质。

## 全透明Transparency材质

外层全透明，内层为其它材质。光线经过全透明时不发生任何反应。

#### tungsten库

直接调用内层材质的sample，evaluate与pdf函数。

#### yocto库

sample函数，参见yocto_shading.h中的sample_passthrough();

```
return -outgoing;
```

evaluate函数

```
if (dot(normal, incoming) * dot(normal, outgoing) >= 0) {
    return vec3f{0, 0, 0};
  } else {
    return vec3f{1, 1, 1};
  }
```

pdf函数

```
if (dot(normal, incoming) * dot(normal, outgoing) >= 0) {
    return 0;
  } else {
    return 1;
  }
```

## 错误材质

又称error。在mitsuba的ErrorBsdf.cpp，很简单直接将albedo设置为纯红。

不过我认为错误材质应该是紫黑格子。——V社玩家后遗症。

错误材质必须是纯紫的。——Unity玩家后遗症。

```
ErrorBsdf::ErrorBsdf()
{
    _albedo = std::make_shared<ConstantTexture>(Vec3f(1.0f, 0.0f, 0.0f));
}
```

# 参考

## Appleseed

![image-20211121131744735](E:\mycode\collection\定理\源码阅读\image-20211121131744735.png)

简介：基于物理的全局光照渲染引擎。代码里的注释很详细，值得初学者学习。

官网：https://appleseedhq.net/

代码：https://github.com/appleseedhq/appleseed

## Blender

![image-20211123154726822](E:\mycode\collection\定理\源码阅读\image-20211123154726822.png)

简介：就是那个大名鼎鼎的blender。

官网：https://www.blender.org/

代码：https://github.com/blender/blender

## Filament

![image-20211121231837183](E:\mycode\collection\定理\源码阅读\image-20211121231837183.png)

简介：谷歌公司的跨平台的基于物理的实时渲染库，github星星12k，fork数1k。不过源代码中注释很少，不怎么容易看懂。甚至有一份官方文档介绍Filament的源码，有中文版。主要为光栅化材质。

中文文档：https://jerkwin.github.io/filamentcn/Filament.md.html#%E5%85%B3%E4%BA%8E

代码：https://github.com/google/filament

## Luxcore

<img src="E:\mycode\collection\定理\源码阅读\image-20211123131257989.png" alt="image-20211123131257989" style="zoom:67%;" />

简介：基于物理的渲染引擎。代码简洁易懂。

官网：https://luxcorerender.org/

## Mitsuba2

<img src="E:\mycode\collection\定理\源码阅读\image-20211121232349530.png" alt="image-20211121232349530" style="zoom:67%;" />

简介：以研究为导向的基于物理的渲染引擎。代码中注释非常详细，值得初学者学习。以研究为导向，说的是很多论文的代码都是基于mitsuba改进的，我在github上见到好几个了。例如“Fluid Engine Development”就是拿这个库渲染的。

官网：https://www.mitsuba-renderer.org/

代码：https://github.com/mitsuba-renderer/mitsuba2

### PBRT-V3

<img src="E:\mycode\collection\定理\源码阅读\image-20211123151139965.png" alt="image-20211123151139965" style="zoom: 67%;" />

简介：“Physically Based Rendering: From Theory To Implementation” 第三版的源代码

网站：http://pbrt.org/

代码：https://github.com/mmp/pbrt-v3

## Tungsten

简介：基于c++11的高性能物理渲染器

网站：https://benedikt-bitterli.me/tungsten.html

### BRDF-Explorer

简介：迪士尼公司自己的开源库，有各种各样光栅化下BRDF的实现。

网站：https://github.com/wdas/brdf

## Yocto

简介：小巧的基于物理的渲染引擎，代码注释详细，且写的简洁紧凑，很适合初学者学习。在yocto_shading.h中记载了各种导体金属的折射率。

官网：https://xelatihy.github.io/yocto-gl/

## Libyafaray

简介：小巧的路径追踪引擎

网站：https://github.com/YafaRay/libYafaRay

当然本篇文章还没有远远没有挖掘完在这些开源渲染器中的宝藏，足够学好一阵子了。如果没有这些世界上优秀的开源渲染器和这些热爱分享的大佬的话，我可能现在还弄不清楚粗糙电介质是个什么东西。