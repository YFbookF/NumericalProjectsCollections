Crash Course in BRDF Implementation  

pdf
$$
F = \frac{f(x)}{pdf(x)} \qquad I = \frac{\frac{diffuse_reflectance}{\pi}(N\cdot L)}{pdf(L)}
$$
Iæ˜¯ weight of the sample  ï¼ŒMost basic sampling method, which is actually a great choice for Lambertian and other diffuse BRDFs is sampling in a cosine-weighted hemisphere, with   
$$
pdf(x) = \frac{N * L}{\pi}
$$
è¿™æ ·é‡‡æ ·å‡½æ•°å°±å˜æˆäº†
$$
I = diffuse\_reflectance
$$
we must calculate the vector ğ‘… (vector -ğ¿ reflected along the normal), but as shown by Blinn
in his optimized version [17], the half vector ğ» can be used instead. To implement sample function in our code we use a method found in Ray Tracing Gems [15]  

=============Advances in Monte Carlo Rendering: The Legacy of Jaroslav KË‡rivanek  

For efficient Monte-Carlo light transport simulation, it is vital to sample paths between camera and light sources which transfer the highest amount of energy while, at the same time, avoid wasting computational time on sampling irrelevant paths.   

================pbrt

è’™ç‰¹å¡æ´›æ ¹æœ¬æ–¹ç¨‹
$$
L_o(p,w_o) = \int f(p,w_o,w_i)L_i(p,w_i)|\cos \theta_i|dw_i \\
\approx \frac{1}{N}\sum_{j=1}^N \frac{f(p,w_o,w_j)L}{p(w_j)}
$$
To actually evaluate the PDF for the cosine-weighted sampling method (which we
showed earlier was p(Ï‰) = cos Î¸/Ï€),   

cosåŠçƒé‡‡æ ·ï¼Œuæ˜¯ä¸¤ä¸ªéšæœºæ•°ï¼Œè¿”å›æ˜¯wi

```
inline Vector3f CosineSampleHemisphere(const Point2f &u) {
    Point2f d = ConcentricSampleDisk(u);
    Float z = std::sqrt(std::max((Float)0, 1 - d.x * d.x - d.y * d.y));
    return Vector3f(d.x, d.y, z);
}
```

è¿™é‡Œçš„wiå°±æ˜¯ä¸Šé¢dwi

```
Float BxDF::Pdf(const Vector3f &wo, const Vector3f &wi) const {
    return SameHemisphere(wo, wi) ? AbsCosTheta(wi) * InvPi : 0;
}
inline bool SameHemisphere(const Vector3f &w, const Vector3f &wp) {
    return w.z * wp.z > 0;
}
```

åˆæ¯”å¦‚Fresnel Blend

```
Spectrum FresnelBlend::Sample_f(const Vector3f &wo, Vector3f *wi,
                                const Point2f &uOrig, Float *pdf,
                                BxDFType *sampledType) const {
    Point2f u = uOrig;
    if (u[0] < .5) {
        u[0] = std::min(2 * u[0], OneMinusEpsilon);
        // Cosine-sample the hemisphere, flipping the direction if necessary
        *wi = CosineSampleHemisphere(u);
        if (wo.z < 0) wi->z *= -1;
    } else {
        u[0] = std::min(2 * (u[0] - .5f), OneMinusEpsilon);
        // Sample microfacet orientation $\wh$ and reflected direction $\wi$
        Vector3f wh = distribution->Sample_wh(wo, u);
        *wi = Reflect(wo, wh);
        if (!SameHemisphere(wo, *wi)) return Spectrum(0.f);
    }
    *pdf = Pdf(wo, *wi);
    return f(wo, *wi);
}

Float FresnelBlend::Pdf(const Vector3f &wo, const Vector3f &wi) const {
    if (!SameHemisphere(wo, wi)) return 0;
    Vector3f wh = Normalize(wo + wi);
    Float pdf_wh = distribution->Pdf(wo, wh);
    return .5f * (AbsCosTheta(wi) * InvPi + pdf_wh / (4 * Dot(wo, wh)));
}
```

è’™ç‰¹å¡æ´›åŸºæœ¬å½¢å¼
$$
\int_a^b f(x)dx \approx \sum_{i=1}^N \frac{f(X_i)}{pdf(X)}
$$
=================Path tracing in Production
Part 1: Modern Path Tracing  

The most important case, however, is chromatic extinction in participating media. That is, the extinction coefficient Î¼t(x, Î») depends on the wavelength. This governs the transmittance term equation (25) which is simply
exp(-Î¼t(Î») â‹… d) for homogeneous media. The mean free path in the medium 1/Î¼t depends on the wavelength in
chromatic media,resulting in very different importance sampling strategies for red vs. blue photons.
This is important for instance when using fully ray traced sub-surface scattering in skin: skin has a particular
look that scatters red light farther than blue light. This is the reason why black and white portrait photography
looks smoother with a red filter  

![image-20211117165545022](E:\mycode\collection\å®šç†\å…‰ç…§\image-20211117165545022.png)
